<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light" />
  <title>Escalada | Dashboard Executivo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter+Tight:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@500;700&display=swap"
    rel="stylesheet"
  />
  <script src="./env.js"></script>
  <script defer src="./data/geo_ceps_dictionary.js"></script>
  <script defer src="./data/modulos_complementares_lookup.js"></script>
  <script>
    // Shim defensivo para scripts legados que ainda tentam usar require() no browser.
    // Evita `ReferenceError: require is not defined` sem bloquear o carregamento da UI.
    if (typeof window.require !== "function") {
      window.require = function () { return {}; };
    }
  </script>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

  <!-- (Opcional) date adapter simples -->
  <script defer src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/index.min.js"></script>

  <!-- Supabase JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Lucide (com fallback + logs) -->
  <script>
    // =========================
    // [UI] Lucide loader pattern
    // =========================
    function loadLucideWithFallback() {
      const PRIMARY = "https://unpkg.com/lucide@0.469.0/dist/umd/lucide.min.js";
      const FALLBACK = "https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js";

      function inject(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.defer = true;
          s.src = src;
          s.onload = () => resolve(src);
          s.onerror = () => reject(new Error("Failed to load: " + src));
          document.head.appendChild(s);
        });
      }

      console.debug("[UI] [icons] loading lucide (primary)", { src: PRIMARY });
      const timeoutMs = 2500;

      return Promise.race([
        inject(PRIMARY),
        new Promise((_, reject) => setTimeout(() => reject(new Error("Lucide primary timeout")), timeoutMs)),
      ])
        .then((src) => {
          console.info("[UI] [icons] lucide loaded", { src });
          return true;
        })
        .catch((err) => {
          console.warn("[UI] [icons] primary failed, trying fallback", { err: String(err) });
          return inject(FALLBACK)
            .then((src) => {
              console.info("[UI] [icons] lucide loaded (fallback)", { src });
              return true;
            })
            .catch((err2) => {
              console.error("[UI] [icons] fallback failed; continuing without icons", { err: String(err2) });
              return false; // never block UI
            });
        });
    }

    function renderIconsNow() {
      try {
        if (window.lucide && typeof window.lucide.createIcons === "function") {
          window.lucide.createIcons();
          console.debug("[UI] [icons] createIcons() ok");
        } else {
          console.debug("[UI] [icons] lucide not available yet");
        }
      } catch (e) {
        console.error("[UI] [icons] createIcons error; continuing", { err: String(e) });
      }
    }

    // Icones: carregamento simples e seguro (evita loop de mutacoes)
    document.addEventListener("DOMContentLoaded", () => {
      loadLucideWithFallback().then(() => renderIconsNow());
    });
  </script>

  <style>
    :root {
      color-scheme: light;
      --sidenav-width: 272px;
      --sidenav-collapsed: 76px;
      --sidebar-toggle-size: 38px;
      --sidebar-toggle-gap: 16px;
      --ink-strong: #0c1735;
      --ink: #1f2b46;
      --ink-soft: #52607f;
      --line: #d9e1f1;
      --surface: #ffffff;
      --surface-soft: #f6f8ff;
      --surface-muted: #eef2ff;
      --brand-deep: #122f9b;
      --brand-primary: #2a4fda;
      --brand-primary-2: #605be5;
      --brand-green: #00d95d;
      --brand-green-2: #00ff85;
      --brand-magenta: #ff00ff;
      --brand-cyan: #00f9ff;
      --shadow-soft: 0 10px 30px rgba(18, 47, 155, 0.08);
      --shadow: 0 16px 44px rgba(18, 47, 155, 0.14);
      --ring: 0 0 0 3px rgba(0, 217, 93, 0.25);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      font-family: "Inter Tight", system-ui, -apple-system, "Segoe UI", sans-serif;
      color: var(--ink);
      background: #f3f6fc;
      background-attachment: fixed;
    }

    body.modal-open {
      overflow: hidden;
    }

    h1,
    h2,
    h3,
    .font-display {
      font-family: "Space Grotesk", "Inter Tight", system-ui, sans-serif;
      letter-spacing: -0.02em;
      color: var(--ink-strong);
    }

    .app-shell {
      position: relative;
      min-height: 100vh;
      background: transparent;
      border: 0;
      border-radius: 0;
      margin: 0;
      overflow: visible;
      box-shadow: none;
    }

    .content-wrap {
      padding-left: var(--sidenav-width);
      transition: padding-left 0.2s ease;
    }

    .sidenav-closed .content-wrap {
      padding-left: var(--sidenav-collapsed);
    }

    .sidenav {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: var(--sidenav-width);
      border-radius: 0;
      z-index: 50;
      overflow: hidden;
      transition: transform 0.22s ease;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      padding: 14px;
      background:
        radial-gradient(circle at 100% 0%, rgba(0, 249, 255, 0.25), transparent 40%),
        radial-gradient(circle at 0% 100%, rgba(0, 255, 133, 0.26), transparent 40%),
        linear-gradient(180deg, #2a4fda 0%, #122f9b 100%);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.16);
    }

    .sidebar-toggle {
      position: fixed;
      left: calc(var(--sidenav-collapsed) - var(--sidebar-toggle-size) - var(--sidebar-toggle-gap));
      top: 14px;
      z-index: 70;
      width: var(--sidebar-toggle-size);
      height: var(--sidebar-toggle-size);
      border-radius: 12px;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink-strong);
      display: grid;
      place-items: center;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      transition: left 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
      font-size: 1.2rem;
      line-height: 1;
    }

    .sidenav-closed .sidenav {
      transform: translateX(calc(-1 * (var(--sidenav-width) - var(--sidenav-collapsed))));
    }

    .sidenav-closed #sidebarContent {
      opacity: 0;
      pointer-events: none;
    }

    body:not(.sidenav-closed) .sidebar-toggle {
      left: calc(var(--sidenav-width) - var(--sidebar-toggle-size) - var(--sidebar-toggle-gap));
    }

    .sidebar-toggle:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow);
    }

    .sidebar-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      gap: 10px;
    }

    .sidebar-section-label {
      font-size: 0.67rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: rgba(255, 255, 255, 0.72);
      margin: 10px 8px 8px;
    }

    .sidebar-nav {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sidebar-nav a {
      display: flex;
      align-items: center;
      gap: 9px;
      border-radius: 12px;
      padding: 9px 10px;
      color: rgba(255, 255, 255, 0.92);
      text-decoration: none;
      border: 1px solid transparent;
      transition: transform 0.15s ease, background 0.15s ease, border 0.15s ease;
      font-size: 0.88rem;
      font-weight: 600;
    }

    .sidebar-nav a:hover {
      transform: translateX(2px);
      border-color: rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.12);
    }

    .sidebar-nav a.nav-active {
      color: #0f222f;
      background: linear-gradient(90deg, var(--brand-green) 0%, var(--brand-green-2) 100%);
      border-color: transparent;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.24);
    }

    .section-band {
      border: 1px solid rgba(18, 47, 155, 0.15);
      border-radius: 20px;
      background:
        radial-gradient(circle at 0% 0%, rgba(0, 249, 255, 0.18), transparent 33%),
        radial-gradient(circle at 100% 0%, rgba(255, 0, 255, 0.14), transparent 33%),
        #f7f9ff;
      box-shadow: var(--shadow-soft);
    }

    .wrap-hero {
      border: 1px solid transparent;
      background: transparent;
    }

    .wrap-soft {
      border: 1px solid rgba(18, 47, 155, 0.08);
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.68);
    }

    .wrap-atmosphere {
      border: 1px solid rgba(18, 47, 155, 0.12);
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.75);
      box-shadow: var(--shadow-soft);
    }

    .card {
      border-radius: 18px;
      border: 1px solid var(--line);
      background: var(--surface);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .card.soft {
      background: var(--surface-soft);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 0.74rem;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink-soft);
      line-height: 1;
      white-space: nowrap;
    }

    .chip.soft {
      background: var(--surface-soft);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 0.7rem;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink-soft);
      white-space: nowrap;
    }

    .btn {
      border: 0;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      line-height: 1;
      font-size: 0.84rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      text-decoration: none;
    }

    .btn:focus-visible,
    .input:focus-visible,
    select:focus-visible {
      outline: none;
      box-shadow: var(--ring);
    }

    .btn-sm {
      padding: 9px 12px;
      font-size: 0.75rem;
      border-radius: 10px;
    }

    .btn-primary {
      color: #fff;
      background: linear-gradient(90deg, var(--brand-primary) 0%, var(--brand-primary-2) 100%);
      box-shadow: 0 10px 20px rgba(42, 79, 218, 0.25);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 24px rgba(42, 79, 218, 0.32);
    }

    .btn-outline {
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink-strong);
    }

    .btn-outline:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-soft);
      background: var(--surface-soft);
    }

    .btn-ghost {
      border: 1px solid transparent;
      background: transparent;
      color: var(--ink-soft);
      padding: 9px 10px;
    }

    .btn-ghost:hover {
      border-color: var(--line);
      background: #fff;
    }

    .btn.is-active,
    .btn-ghost.is-active {
      background: linear-gradient(90deg, var(--brand-green) 0%, var(--brand-green-2) 100%);
      color: #07231a;
      border-color: transparent;
      box-shadow: 0 8px 16px rgba(0, 217, 93, 0.26);
    }

    .input,
    select,
    input[type="date"],
    input[type="text"] {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 11px;
      font-size: 0.85rem;
      background: #fff;
      color: var(--ink-strong);
    }

    .label {
      font-size: 0.73rem;
      font-weight: 600;
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .kpi {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .kpi .value {
      font-family: "Space Grotesk", "Inter Tight", sans-serif;
      font-size: 1.35rem;
      font-weight: 700;
      color: var(--ink-strong);
      line-height: 1;
    }

    .kpi .delta {
      font-size: 0.72rem;
      font-weight: 600;
      color: var(--ink-soft);
    }

    .kpi .delta.positive {
      color: #00a64b;
    }

    .kpi .delta.negative {
      color: #d11470;
    }

    .kpi-compact .label {
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.07em;
      font-size: 0.67rem;
      font-weight: 700;
    }

    .progress {
      margin-top: 8px;
      width: 100%;
      height: 6px;
      background: rgba(42, 79, 218, 0.15);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress span {
      height: 100%;
      display: block;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--brand-green), var(--brand-green-2));
      width: 0%;
      transition: width 0.3s ease;
    }

    .metric {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .metric .label {
      color: var(--ink-soft);
      font-size: 0.67rem;
    }

    .metric .value {
      font-size: 1.02rem;
      font-weight: 700;
      color: var(--ink-strong);
    }

    .section-title {
      font-size: 0.95rem;
      font-weight: 700;
      margin: 0;
      color: var(--ink-strong);
      line-height: 1.2;
    }

    .insight-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 8px;
    }

    .insight-list li {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 0.78rem;
      color: var(--ink-soft);
      background: #fff;
      line-height: 1.35;
    }

    .uf-pills {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
      scrollbar-width: thin;
    }

    .uf-pill {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      color: var(--ink-strong);
      padding: 9px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 0.82rem;
      font-weight: 600;
      transition: border 0.15s ease, transform 0.15s ease, background 0.15s ease;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .uf-pill:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 79, 218, 0.44);
    }

    .uf-pill.active {
      border-color: transparent;
      background: linear-gradient(90deg, var(--brand-primary) 0%, var(--brand-primary-2) 100%);
      color: #fff;
      box-shadow: 0 10px 18px rgba(42, 79, 218, 0.3);
    }

    .leaflet-map-host {
      position: relative;
      background: linear-gradient(180deg, #091a3f 0%, #08122e 100%);
    }

    #map,
    #mapTerritory {
      min-height: 220px;
    }

    .leaflet-map-host .leaflet-container {
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: "Inter Tight", system-ui, -apple-system, "Segoe UI", sans-serif;
    }

    .leaflet-map-host .leaflet-control-zoom a {
      width: 30px;
      height: 30px;
      line-height: 30px;
      border-radius: 9px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      color: #e2e8f0;
      background: rgba(15, 23, 42, 0.88);
    }

    .leaflet-map-host .leaflet-control-zoom a:hover {
      background: rgba(30, 41, 59, 0.96);
      color: #f8fafc;
    }

    body.pdf-capture-mode .leaflet-tile-pane,
    body.pdf-capture-mode .leaflet-control-container {
      visibility: hidden !important;
    }

    body.pdf-capture-mode .leaflet-pane canvas {
      display: none !important;
    }

    .leaflet-heat-legend {
      padding: 5px 7px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(8, 14, 34, 0.78);
      color: #e2e8f0;
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.28);
      min-width: 92px;
    }

    .leaflet-heat-legend .bar {
      height: 6px;
      border-radius: 999px;
      margin-bottom: 4px;
      background: linear-gradient(90deg, #12309b 0%, #2a4fda 20%, #00f9ff 40%, #00d95d 62%, #ffc940 80%, #ff3b30 100%);
    }

    .leaflet-heat-legend .labels {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      letter-spacing: 0.02em;
      gap: 6px;
    }

    .leaflet-heat-legend .labels span {
      white-space: nowrap;
    }

    .leaflet-heat-legend .meta {
      margin-top: 3px;
      font-size: 8px;
      color: #cbd5e1;
      letter-spacing: 0.03em;
    }

    .leaflet-tooltip.heat-tooltip {
      background: rgba(7, 15, 36, 0.94);
      border: 1px solid rgba(148, 163, 184, 0.42);
      color: #e2e8f0;
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(2, 6, 23, 0.42);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.35;
    }

    .leaflet-tooltip-top.heat-tooltip:before {
      border-top-color: rgba(148, 163, 184, 0.42);
    }

    .leaflet-tooltip-bottom.heat-tooltip:before {
      border-bottom-color: rgba(148, 163, 184, 0.42);
    }

    .heat-tip-title {
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 4px;
    }

    .city-focus-btn {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      text-align: left;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease, background 0.15s ease;
    }

    .top-cities-pills .city-focus-btn {
      width: auto;
      flex: 0 0 auto;
      min-width: 220px;
    }

    .city-focus-btn:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 79, 218, 0.42);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
    }

    .city-focus-btn.active {
      border-color: transparent;
      background: linear-gradient(90deg, var(--brand-primary) 0%, var(--brand-primary-2) 100%);
      box-shadow: 0 12px 22px rgba(42, 79, 218, 0.26);
    }

    .city-focus-btn.active .city-focus-label,
    .city-focus-btn.active .city-focus-value {
      color: #fff;
    }

    .city-focus-label {
      color: #1e293b;
      font-size: 0.86rem;
      font-weight: 600;
      line-height: 1.2;
    }

    .city-focus-value {
      color: #64748b;
      font-size: 0.78rem;
      font-weight: 700;
      flex-shrink: 0;
    }

    .map-empty-state {
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 420;
      padding: 7px 9px;
      border-radius: 9px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(8, 14, 34, 0.84);
      color: #e2e8f0;
      font-size: 12px;
      line-height: 1.25;
    }

    table thead th {
      font-size: 0.67rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .table-row {
      border-bottom: 1px solid #edf1fb;
    }

    .table-row:hover td {
      background: #f7faff;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 12, 35, 0.5);
      z-index: 80;
      display: none;
      place-items: center;
      padding: 20px;
    }

    .modal-backdrop:not(.hidden) {
      display: grid;
    }

    .modal-card {
      width: min(560px, 92vw);
      border-radius: 18px;
      border: 1px solid var(--line);
      background: #fff;
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .uf-onboarding-list {
      max-height: min(54vh, 340px);
      overflow: auto;
      display: grid;
      gap: 8px;
      padding-right: 4px;
    }

    .uf-onboarding-item {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
      color: var(--ink-strong);
      text-align: left;
      padding: 10px 12px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .uf-onboarding-item:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 79, 218, 0.5);
      background: #f8fbff;
    }

    .auth-gate {
      position: fixed;
      inset: 0;
      z-index: 90;
      background: rgba(7, 15, 38, 0.62);
      backdrop-filter: blur(4px);
      display: none;
      place-items: center;
      padding: 20px;
    }

    .auth-gate:not(.hidden) {
      display: grid;
    }

    .auth-card {
      width: min(520px, 94vw);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .boot-loading-gate {
      position: fixed;
      inset: 0;
      z-index: 96;
      background: rgba(7, 15, 38, 0.7);
      backdrop-filter: blur(4px);
      display: none;
      place-items: center;
      padding: 20px;
    }

    .boot-loading-gate:not(.hidden) {
      display: grid;
    }

    .boot-loading-card {
      width: min(520px, 94vw);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.96);
      padding: 22px;
      box-shadow: var(--shadow);
    }

    .loading-spinner {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 3px solid rgba(42, 79, 218, 0.22);
      border-top-color: #2a4fda;
      animation: spin 0.85s linear infinite;
      flex-shrink: 0;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .skeleton {
      background: linear-gradient(90deg, rgba(18, 47, 155, 0.08), rgba(18, 47, 155, 0.02), rgba(18, 47, 155, 0.08));
      background-size: 200% 100%;
      animation: shimmer 1.15s infinite linear;
      border-radius: 14px;
    }

    @keyframes shimmer {
      from {
        background-position: 0% 0;
      }
      to {
        background-position: -200% 0;
      }
    }

    @keyframes rise {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .reveal {
      animation: rise 0.6s ease both;
    }

    .delay-1 {
      animation-delay: 0.08s;
    }

    .delay-2 {
      animation-delay: 0.16s;
    }

    .delay-3 {
      animation-delay: 0.24s;
    }

    canvas {
      max-width: 100%;
      display: block;
    }

    .modal-open .blur-target {
      filter: blur(3px);
    }

    @media (max-width: 1024px) {
      .app-shell {
        margin: 0;
        border-radius: 0;
        border: 0;
      }

      .sidenav {
        top: 0;
        bottom: 0;
        left: 0;
        width: min(var(--sidenav-width), 86vw);
        border-radius: 0;
        transform: translateX(-100%);
      }

      .sidenav-closed .sidenav {
        transform: translateX(-100%);
      }

      .sidenav-closed #sidebarContent {
        opacity: 1;
        pointer-events: auto;
      }

      .content-wrap,
      .sidenav-closed .content-wrap {
        padding-left: 0;
      }

      body:not(.sidenav-closed) .sidebar-toggle {
        left: calc(min(var(--sidenav-width), 86vw) - var(--sidebar-toggle-size) - var(--sidebar-toggle-gap));
      }
    }

    @media print {
      body {
        background: #ffffff !important;
      }

      #sidebar,
      #sidebarToggle,
      #btnOpenFilters,
      #btnExportCsv,
      #toast,
      #filterModal,
      #ufWelcomeModal,
      #bootLoadingGate,
      #authGate {
        display: none !important;
      }

      .content-wrap {
        padding-left: 0 !important;
      }

      [data-page],
      .card {
        break-inside: avoid;
        page-break-inside: avoid;
      }
    }
  </style>
</head>

<body class="min-h-screen sidenav-closed">
  <script>
    // =========================================================
    // [UI] helper utilities
    // =========================================================
    console.info("[UI] dashboard boot");

    function fmtInt(n) {
      const x = Number(n || 0);
      return x.toLocaleString("pt-BR");
    }
    function fmtTrunc1(n) {
      const x = Number(n || 0);
      const t = Math.trunc(x * 10) / 10;
      return t.toLocaleString("pt-BR", { minimumFractionDigits: 1, maximumFractionDigits: 1 });
    }
    function fmtPct(p) {
      const x = Number(p || 0);
      return (x * 100).toFixed(1).replace(".", ",") + "%";
    }
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function fmtDateBr(dateStr) {
      const s = String(dateStr || "").trim();
      if (!s) return "--";

      let m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) m = s.match(/^(\d{4})-(\d{2})-(\d{2})T/);
      if (m) return `${m[3]}/${m[2]}/${m[1]}`;

      const d = new Date(s);
      if (Number.isNaN(d.getTime())) return "--";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = String(d.getFullYear());
      return `${dd}/${mm}/${yyyy}`;
    }

    function fmtDateTimeBr(dateIso) {
      return fmtDateBr(dateIso);
    }

    function downloadText(filename, content, mime = "text/plain;charset=utf-8") {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 500);
    }

    function dateFromStr(dateStr) {
      const [y, m, d] = String(dateStr || "").split("-").map(Number);
      if (!y || !m || !d) return null;
      return new Date(Date.UTC(y, m - 1, d));
    }

    function shiftDate(dateStr, days) {
      const base = dateFromStr(dateStr);
      if (!base) return dateStr;
      base.setUTCDate(base.getUTCDate() + days);
      return base.toISOString().slice(0, 10);
    }

    function diffDaysInclusive(a, b) {
      const da = dateFromStr(a);
      const db = dateFromStr(b);
      if (!da || !db) return 0;
      return Math.floor((db - da) / (24 * 60 * 60 * 1000)) + 1;
    }

    function hashString(str) {
      let h = 0;
      const s = String(str || "");
      for (let i = 0; i < s.length; i++) {
        h = (h << 5) - h + s.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h);
    }

    const CHANNELS = ["Portal", "WhatsApp", "Escola", "Evento", "Parceiro", "Telefone"];
    const UF_SIGLAS = {
      "Acre": "AC",
      "Alagoas": "AL",
      "Amapá": "AP",
      "Amapa": "AP",
      "Amazonas": "AM",
      "Bahia": "BA",
      "Ceará": "CE",
      "Ceara": "CE",
      "Distrito Federal": "DF",
      "Espírito Santo": "ES",
      "Espirito Santo": "ES",
      "Goiás": "GO",
      "Goias": "GO",
      "Maranhão": "MA",
      "Maranhao": "MA",
      "Mato Grosso": "MT",
      "Mato Grosso do Sul": "MS",
      "Minas Gerais": "MG",
      "Pará": "PA",
      "Para": "PA",
      "Paraíba": "PB",
      "Paraiba": "PB",
      "Paraná": "PR",
      "Parana": "PR",
      "Pernambuco": "PE",
      "Piauí": "PI",
      "Piaui": "PI",
      "Rio de Janeiro": "RJ",
      "Rio Grande do Norte": "RN",
      "Rio Grande do Sul": "RS",
      "Rondônia": "RO",
      "Rondonia": "RO",
      "Roraima": "RR",
      "Santa Catarina": "SC",
      "São Paulo": "SP",
      "Sao Paulo": "SP",
      "Sergipe": "SE",
      "Tocantins": "TO"
    };
    const UF_NAME_TO_SIGLA = {
      "ACRE": "AC",
      "ALAGOAS": "AL",
      "AMAPA": "AP",
      "AMAZONAS": "AM",
      "BAHIA": "BA",
      "CEARA": "CE",
      "DISTRITO FEDERAL": "DF",
      "ESPIRITO SANTO": "ES",
      "GOIAS": "GO",
      "MARANHAO": "MA",
      "MATO GROSSO": "MT",
      "MATO GROSSO DO SUL": "MS",
      "MINAS GERAIS": "MG",
      "PARA": "PA",
      "PARAIBA": "PB",
      "PARANA": "PR",
      "PERNAMBUCO": "PE",
      "PIAUI": "PI",
      "RIO DE JANEIRO": "RJ",
      "RIO GRANDE DO NORTE": "RN",
      "RIO GRANDE DO SUL": "RS",
      "RONDONIA": "RO",
      "RORAIMA": "RR",
      "SANTA CATARINA": "SC",
      "SAO PAULO": "SP",
      "SERGIPE": "SE",
      "TOCANTINS": "TO"
    };
    const UF_CENTROIDS = {
      "AC": { city: "Rio Branco", lat: -9.975, lng: -67.8243 },
      "AL": { city: "Maceio", lat: -9.66599, lng: -35.735 },
      "AP": { city: "Macapa", lat: 0.0349, lng: -51.0694 },
      "AM": { city: "Manaus", lat: -3.119, lng: -60.0217 },
      "BA": { city: "Salvador", lat: -12.9777, lng: -38.5016 },
      "CE": { city: "Fortaleza", lat: -3.7319, lng: -38.5267 },
      "DF": { city: "Brasilia", lat: -15.7801, lng: -47.9292 },
      "ES": { city: "Vitoria", lat: -20.3155, lng: -40.3128 },
      "GO": { city: "Goiania", lat: -16.6869, lng: -49.2648 },
      "MA": { city: "Sao Luis", lat: -2.5387, lng: -44.2825 },
      "MT": { city: "Cuiaba", lat: -15.6014, lng: -56.0979 },
      "MS": { city: "Campo Grande", lat: -20.4697, lng: -54.6201 },
      "MG": { city: "Belo Horizonte", lat: -19.9167, lng: -43.9345 },
      "PA": { city: "Belem", lat: -1.4558, lng: -48.5039 },
      "PB": { city: "Joao Pessoa", lat: -7.1151, lng: -34.8641 },
      "PR": { city: "Curitiba", lat: -25.4284, lng: -49.2733 },
      "PE": { city: "Recife", lat: -8.0476, lng: -34.877 },
      "PI": { city: "Teresina", lat: -5.0919, lng: -42.8034 },
      "RJ": { city: "Rio de Janeiro", lat: -22.9068, lng: -43.1729 },
      "RN": { city: "Natal", lat: -5.7945, lng: -35.211 },
      "RS": { city: "Porto Alegre", lat: -30.0346, lng: -51.2177 },
      "RO": { city: "Porto Velho", lat: -8.7608, lng: -63.8999 },
      "RR": { city: "Boa Vista", lat: 2.8235, lng: -60.6753 },
      "SC": { city: "Florianopolis", lat: -27.5949, lng: -48.5482 },
      "SP": { city: "Sao Paulo", lat: -23.5505, lng: -46.6333 },
      "SE": { city: "Aracaju", lat: -10.9472, lng: -37.0731 },
      "TO": { city: "Palmas", lat: -10.184, lng: -48.3336 }
    };
    const UF_CODE_TO_NAME = {
      AC: "Acre",
      AL: "Alagoas",
      AP: "Amapa",
      AM: "Amazonas",
      BA: "Bahia",
      CE: "Ceara",
      DF: "Distrito Federal",
      ES: "Espirito Santo",
      GO: "Goias",
      MA: "Maranhao",
      MT: "Mato Grosso",
      MS: "Mato Grosso do Sul",
      MG: "Minas Gerais",
      PA: "Para",
      PB: "Paraiba",
      PR: "Parana",
      PE: "Pernambuco",
      PI: "Piaui",
      RJ: "Rio de Janeiro",
      RN: "Rio Grande do Norte",
      RS: "Rio Grande do Sul",
      RO: "Rondonia",
      RR: "Roraima",
      SC: "Santa Catarina",
      SP: "Sao Paulo",
      SE: "Sergipe",
      TO: "Tocantins",
    };
    const UF_CITY_TOTALS = {
      AC: 22, AL: 102, AM: 62, AP: 16, BA: 417, CE: 184, DF: 1, ES: 78, GO: 246, MA: 217,
      MG: 853, MS: 79, MT: 141, PA: 144, PB: 223, PE: 185, PI: 224, PR: 399, RJ: 92, RN: 167,
      RO: 52, RR: 15, RS: 497, SC: 295, SE: 75, SP: 645, TO: 139
    };
    const KPI_TARGETS = {
      atendimentos: 120000,
      inscricoes: 45000,
      inscritos: 45000,
      conversaoAtendimento: 0.32
    };

    function deriveChannel(e) {
      if (e.channel) return e.channel;
      const seed = `${e.user_id || ""}|${e.date || ""}|${e.type || ""}|${e.uf || ""}`;
      return CHANNELS[hashString(seed) % CHANNELS.length];
    }

    function deriveDuration(e) {
      if (Number.isFinite(e.duration_min)) return e.duration_min;
      const seed = `${e.user_id || ""}|${e.date || ""}|${e.type || ""}`;
      return 8 + (hashString(seed) % 42);
    }

    function ufSigla(name) {
      return UF_SIGLAS[name] || String(name || "").slice(0, 2).toUpperCase();
    }

    function normalizeTextKey(value) {
      return String(value || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .trim()
        .toUpperCase();
    }

    function normalizeLooseLabel(value) {
      return normalizeTextKey(value)
        .replace(/[^A-Z0-9]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    const COMPETENCY_MODES = Object.freeze({
      BNCC: "bncc",
      ENTRECOMP: "entrecomp",
    });
    const CONTENT_TYPE_KEYS = new Set(["AULA", "QUIZ", "DOWNLOAD", "EBOOK", "ARTIGO"]);
    const MODULOS_COMPLEMENTARES_LOOKUP = window.__MODULOS_COMPLEMENTARES_LOOKUP__ || {};
    const UNMAPPED_LABEL = "Não mapeado";

    const MACROTEMA_CATALOG = Object.freeze({
      autoconhecimento: {
        title: "Jornada do Eu",
        aliases: [
          "Autoconhecimento",
          "Autoconhecimento e Projeto de Vida",
          "Jornada do Eu",
        ],
      },
      "cultura-digital": {
        title: "Caixa de Ferramentas Digitais",
        aliases: [
          "Caixa de Ferramentas Digitais",
          "Competências Empreendedoras e Cultura digital",
          "Competências empreendedoras e Cultura digital",
          "Competências Empreendedoras",
          "Cultura Digital",
        ],
      },
      ferramentas: {
        title: "Oficina de Soluções",
        aliases: [
          "Ferramentas analógicas e digitais",
          "Ferramentas e Aplicações",
          "Oficina de Soluções",
        ],
      },
      colaboracao: {
        title: "Conexões que Constroem",
        aliases: [
          "Colaboração e Gestão de projetos",
          "Conexões que Constroem",
          "Colaboração e Gestão",
        ],
      },
      cidadania: {
        title: "Nossa Pegada no Mundo",
        aliases: [
          "Cidadania e sustentabilidade",
          "Cidadania e Sustentabilidade",
          "Nossa Pegada no Mundo",
        ],
      },
      empreendedorismo: {
        title: "Impulso para o Futuro",
        aliases: [
          "Empreendedorismo e Mundo do Trabalho",
          "Empreendedorismo e Carreira",
          "Impulso para o Futuro",
        ],
      },
    });

    const MODULE_CATALOG = Object.freeze([
      { id: "CI-0", title: "Como transformar ideias em ação?", macrotemaId: "empreendedorismo", bncc: "8", entrecomp: "Rec 2.1", aliases: ["Ciclo da Inovação"] },
      { id: "CI-1", title: "Fontes de Inspiração", macrotemaId: "empreendedorismo", bncc: "10", entrecomp: "I&O 1.1", aliases: ["Etapa de Inspiração"] },
      { id: "CI-2", title: "Tempestade de ideias", macrotemaId: "empreendedorismo", bncc: "2", entrecomp: "I&O 1.2 + 1.3", aliases: ["Etapa de Ideação"] },
      { id: "CI-3", title: "Mão na massa: a primeira versão", macrotemaId: "empreendedorismo", bncc: "6", entrecomp: "Ação 3.3", aliases: ["Etapa de Prototipação"] },
      { id: "CI-4", title: "Minha solução no Mundo", macrotemaId: "empreendedorismo", bncc: "9", entrecomp: "Ação 3.4", aliases: ["Etapa de Compartilhamento"] },
      { id: "DP1", title: "Quem sou eu?", macrotemaId: "autoconhecimento", bncc: "8", entrecomp: "1.1 + 3.1", aliases: ["Quem é você?"] },
      { id: "DP2", title: "Como parar de viver no automático?", macrotemaId: "autoconhecimento", bncc: "8", entrecomp: "2.1", aliases: ["Um passo por vez"] },
      { id: "DP7", title: "Explorando caminhos para o futuro", macrotemaId: "autoconhecimento", bncc: "8", entrecomp: "5.1 + 5.2", aliases: ["O que quero cultivar para o futuro?"] },
      { id: "DP3", title: "Ninguém escalada sozinho", macrotemaId: "autoconhecimento", bncc: "9", entrecomp: "Rec 2.5", aliases: ["Relações que me constroem"] },
      { id: "GF1", title: "Por que meu dinheiro nunca sobra?", macrotemaId: "cultura-digital", bncc: "6", entrecomp: "4.1 + 4.2", aliases: ["Detector de Vazamento"] },
      { id: "GF2", title: "Olha o Pix aê!", macrotemaId: "cultura-digital", bncc: "6", entrecomp: "4.1 + 4.2", aliases: ["PIX Invisível", "Pix invisível"] },
      { id: "DP4", title: "Hackeando o meu Feed", macrotemaId: "cultura-digital", bncc: "5", entrecomp: "1.2 + 1.4", aliases: ["Curadoria Digital & Escolhas Conscientes", "Curadoria digital"] },
      { id: "DP5", title: "Olhar Empreendedor para o Mundo", macrotemaId: "cultura-digital", bncc: "6", entrecomp: "I&O 1.1", aliases: ["Consciência Empreendedora"] },
      { id: "DP8", title: "Conexões que importam", macrotemaId: "ferramentas", bncc: "EF09CI15", entrecomp: "I&O 1.2 + 1.3", aliases: ["Colaboração Digital"] },
      { id: "PR2", title: "Na Raiz do Problema", macrotemaId: "ferramentas", bncc: "7", entrecomp: "1.4 + 3.2", aliases: ["Identificação de Causas & Problemas", "Identificação de causas & problemas"] },
      { id: "PR4", title: "Testar, errar & melhorar", macrotemaId: "ferramentas", bncc: "2", entrecomp: "I&O 1.2 + 1.3", aliases: ["Protótipos & Testes", "Protótipos e testes"] },
      { id: "DP6", title: "Como colocar ideas em movimento?", macrotemaId: "colaboracao", bncc: "2", entrecomp: "I&O 1.2 + 1.3", aliases: ["Boas ideias mudam o mundo"] },
      { id: "PR5", title: "Como gerar engajamento nas soluções?", macrotemaId: "colaboracao", bncc: "9", entrecomp: "I&O 1.2 + 1.3", aliases: ["Compartilhamento & Mobilização", "Compartilhamento e mobilização"] },
      { id: "PR1", title: "Mapeando realidades e construindo a mudança", macrotemaId: "colaboracao", bncc: "10", entrecomp: "I&O 1.2/1.3", aliases: ["Sensibilização & Escuta do Território", "Sensibilização e escuta do território"] },
      { id: "PR3", title: "Do planejamento à ação", macrotemaId: "colaboracao", bncc: "8", entrecomp: "3.1 + 3.2", aliases: ["Planejamento Simples de Ações", "Planejamento simples de ações"] },
      { id: "ODS1", title: "Escolhas Sustentáveis na Prática", macrotemaId: "cidadania", bncc: "10", entrecomp: "1.5, 2.4, 3.1, 3.5", aliases: ["Nossa Pegada no Mundo", "Cidadania e Sustentabilidade", "Sustentabilidade prática"] },
    ]);

    const MACROTEMA_ALIAS_TO_ID = (() => {
      const aliases = new Map();
      for (const [macrotemaId, def] of Object.entries(MACROTEMA_CATALOG)) {
        aliases.set(normalizeLooseLabel(macrotemaId), macrotemaId);
        aliases.set(normalizeLooseLabel(def.title), macrotemaId);
        for (const alias of def.aliases || []) {
          aliases.set(normalizeLooseLabel(alias), macrotemaId);
        }
      }
      return aliases;
    })();

    const MODULE_COMPLEMENTARY_BY_TITLE = (() => {
      const byTitle = new Map();
      for (const [titleRaw, metaRaw] of Object.entries(MODULOS_COMPLEMENTARES_LOOKUP || {})) {
        const title = String(titleRaw || "").trim();
        const titleKey = normalizeLooseLabel(title);
        if (!title || !titleKey) continue;
        const aliases = Array.isArray(metaRaw?.aliases) ? metaRaw.aliases : [];
        byTitle.set(titleKey, {
          title,
          trail: String(metaRaw?.trail || "").trim(),
          aliases: aliases.map((v) => String(v || "").trim()).filter(Boolean),
        });
      }
      return byTitle;
    })();

    const MODULE_CATALOG_ENRICHED = (() => {
      const merged = [];
      const seenTitleKeys = new Set();
      let extraIdx = 1;

      for (const base of MODULE_CATALOG) {
        const baseTitleKey = normalizeLooseLabel(base.title);
        const ext = MODULE_COMPLEMENTARY_BY_TITLE.get(baseTitleKey);
        const aliases = [...new Set([
          ...(base.aliases || []),
          ...(ext?.aliases || []),
        ])];
        merged.push({
          ...base,
          trail: String(ext?.trail || base.trail || "").trim(),
          aliases,
        });
        seenTitleKeys.add(baseTitleKey);
      }

      // módulos presentes no modulos.html, mas fora do catálogo principal
      for (const [titleKey, ext] of MODULE_COMPLEMENTARY_BY_TITLE.entries()) {
        if (seenTitleKeys.has(titleKey)) continue;
        merged.push({
          id: `EXT-${extraIdx++}`,
          title: ext.title,
          macrotemaId: "",
          bncc: "",
          entrecomp: "",
          trail: ext.trail,
          aliases: [...new Set([ext.title, ...(ext.aliases || [])])],
        });
      }

      return Object.freeze(merged);
    })();

    const MODULE_TITLE_TO_META = (() => {
      const byTitle = new Map();
      const register = (title, meta) => {
        const key = normalizeLooseLabel(title);
        if (!key || byTitle.has(key)) return;
        byTitle.set(key, meta);
      };

      for (const mod of MODULE_CATALOG_ENRICHED) {
        register(mod.title, mod);
        register(mod.id, mod);
        register(mod.trail, mod);
        for (const alias of mod.aliases || []) register(alias, mod);
      }
      return byTitle;
    })();

    function resolveMacrotemaId(rawValue) {
      const key = normalizeLooseLabel(rawValue);
      if (!key) return "";
      return MACROTEMA_ALIAS_TO_ID.get(key) || "";
    }

    function resolveMacrotemaLabel(rawValue, strict = false) {
      const macrotemaId = resolveMacrotemaId(rawValue);
      if (macrotemaId && MACROTEMA_CATALOG[macrotemaId]) {
        return MACROTEMA_CATALOG[macrotemaId].title;
      }
      if (strict) return "";
      const fallback = String(rawValue || "").trim();
      return fallback ? toSentenceCase(fallback) : "";
    }

    function resolveModuleByTitle(rawTitle) {
      const key = normalizeLooseLabel(rawTitle);
      if (!key) return null;
      const exact = MODULE_TITLE_TO_META.get(key);
      if (exact) return exact;
      for (const [aliasKey, meta] of MODULE_TITLE_TO_META.entries()) {
        if (key.includes(aliasKey) || aliasKey.includes(key)) return meta;
      }
      return null;
    }

    function resolveModuleFromEvent(event) {
      const candidates = [
        event?.modulo,
        event?.module,
        event?.module_title,
        event?.nome_item,
        event?.item,
        event?.material_type,
      ];
      for (const candidate of candidates) {
        const match = resolveModuleByTitle(candidate);
        if (match) return match;
      }
      return null;
    }

    function splitCompetencyValues(rawValue) {
      const source = String(rawValue || "").trim();
      if (!source) return [];
      const values = [];
      const chunks = source.split(/\s*,\s*/).map((x) => x.trim()).filter(Boolean);

      for (const chunk of chunks) {
        const parts = chunk.split(/\s*(?:\+|\/| e )\s*/i).map((x) => x.trim()).filter(Boolean);
        if (!parts.length) continue;

        let inheritedPrefix = "";
        const first = parts[0];
        const firstMatch = first.match(/^([\p{L}&.\- ]+)\s+([0-9].*)$/u);
        if (firstMatch) {
          inheritedPrefix = firstMatch[1].trim();
          values.push(`${inheritedPrefix} ${firstMatch[2].trim()}`.replace(/\s+/g, " "));
        } else {
          values.push(first.replace(/\s+/g, " "));
        }

        for (let i = 1; i < parts.length; i++) {
          const piece = parts[i];
          if (!piece) continue;
          const withPrefix = (/^[0-9]/.test(piece) && inheritedPrefix)
            ? `${inheritedPrefix} ${piece}`
            : piece;
          values.push(withPrefix.replace(/\s+/g, " "));
        }
      }

      return Array.from(new Set(values.map((v) => v.trim()).filter(Boolean)));
    }

    function formatCompetencyLabel(rawLabel) {
      const label = String(rawLabel || "").trim();
      if (!label) return "";
      if (/^C-\s*/i.test(label)) return label.replace(/^C-\s*/i, "C-");
      if (/^\d+(?:[.,]\d+)?$/.test(label)) return `C-${label.replace(",", ".")}`;
      return label;
    }

    function normalizeContentTypeKey(rawValue) {
      const normalized = normalizeTextKey(rawValue)
        .replace(/\s*\([^)]*\)\s*$/g, "")
        .trim();
      if (normalized === "E BOOK" || normalized === "E-BOOK") return "EBOOK";
      return normalized;
    }

    function isContentExplorationEvent(event) {
      const typeKey = normalizeContentTypeKey(event?.type);
      if (!typeKey) {
        return Boolean(
          String(event?.material_type || "").trim() ||
          String(event?.nome_item || "").trim() ||
          String(event?.modulo || event?.module || "").trim()
        );
      }
      if (typeKey === "INSCRICAO" || typeKey === "EVENTO") return false;
      if (typeKey === "ATENDIMENTO" || typeKey === "ACAO") return true;
      return CONTENT_TYPE_KEYS.has(typeKey);
    }

    function toSortedPairs(countMap, limit = Number.POSITIVE_INFINITY) {
      return Array.from(countMap.entries())
        .filter(([, v]) => Number(v || 0) > 0)
        .sort((a, b) => {
          const diff = Number(b[1] || 0) - Number(a[1] || 0);
          if (diff !== 0) return diff;
          return String(a[0]).localeCompare(String(b[0]), "pt-BR");
        })
        .slice(0, limit);
    }

    function toPercentagePairs(pairs, limit = 10) {
      const source = Array.isArray(pairs) ? pairs : [];
      const total = source.reduce((sum, [, v]) => sum + Number(v || 0), 0);
      if (!Number.isFinite(total) || total <= 0) return [];
      return source
        .map(([k, v]) => [k, (Number(v || 0) / total) * 100])
        .sort((a, b) => Number(b[1] || 0) - Number(a[1] || 0))
        .slice(0, limit);
    }

    function addWeightedCount(countMap, label, weight = 1) {
      const key = String(label || "").trim();
      const value = Number(weight || 0);
      if (!key || !Number.isFinite(value) || value <= 0) return;
      countMap.set(key, Number(countMap.get(key) || 0) + value);
    }

    function addMacrotemaCount(countMap, rawValue, weight = 1, strict = false, unmappedLabel = UNMAPPED_LABEL) {
      const label = resolveMacrotemaLabel(rawValue, strict);
      if (label) {
        addWeightedCount(countMap, label, weight);
        return true;
      }
      addWeightedCount(countMap, unmappedLabel, weight);
      return false;
    }

    function addKnownMacrotemaCount(countMap, rawValue, weight = 1) {
      const macrotemaId = resolveMacrotemaId(rawValue);
      if (!macrotemaId || !MACROTEMA_CATALOG[macrotemaId]) return false;
      addWeightedCount(countMap, MACROTEMA_CATALOG[macrotemaId].title, weight);
      return true;
    }

    function addCompetencyDistribution(countMap, rawValue, weight = 1) {
      const totalWeight = Number(weight || 0);
      if (!Number.isFinite(totalWeight) || totalWeight <= 0) return false;
      const competencies = splitCompetencyValues(rawValue);
      if (!competencies.length) {
        return false;
      }
      const portion = totalWeight / competencies.length;
      for (const competency of competencies) {
        addWeightedCount(countMap, formatCompetencyLabel(competency), portion);
      }
      return true;
    }

    function collectMacrotemaPairsFromEvents(events, limit = Number.POSITIVE_INFINITY) {
      const counts = new Map();
      for (const e of events || []) {
        if (!isContentExplorationEvent(e)) continue;
        const mod = resolveModuleFromEvent(e);
        if (mod?.macrotemaId) {
          addKnownMacrotemaCount(counts, mod.macrotemaId, 1);
          continue;
        }
        addKnownMacrotemaCount(counts, e?.macrotema, 1);
      }
      return toSortedPairs(counts, limit);
    }

    function collectMacrotemaPairsFromItemPairs(itemPairs, fallbackPairs = [], limit = Number.POSITIVE_INFINITY) {
      const counts = new Map();
      for (const [itemLabel, countRaw] of (itemPairs || [])) {
        const weight = Number(countRaw || 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;
        const mod = resolveModuleByTitle(itemLabel);
        if (mod?.macrotemaId) {
          addKnownMacrotemaCount(counts, mod.macrotemaId, weight);
          continue;
        }
        addKnownMacrotemaCount(counts, itemLabel, weight);
      }
      if (counts.size) return toSortedPairs(counts, limit);

      const fallback = new Map();
      for (const [label, countRaw] of (fallbackPairs || [])) {
        const weight = Number(countRaw || 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;
        addKnownMacrotemaCount(fallback, label, weight);
      }
      return toSortedPairs(fallback, limit);
    }

    function getEventCompetencyRaw(event, mode) {
      if (mode === COMPETENCY_MODES.ENTRECOMP) {
        return event?.entrecomp ?? event?.competencia_entrecomp ?? event?.competencias_entrecomp ?? "";
      }
      return event?.bncc ?? event?.competencia_bncc ?? event?.competencias_bncc ?? "";
    }

    function collectCompetencyPairsFromEvents(events, mode = COMPETENCY_MODES.BNCC, limit = Number.POSITIVE_INFINITY) {
      const counts = new Map();
      for (const e of events || []) {
        if (!isContentExplorationEvent(e)) continue;
        const mod = resolveModuleFromEvent(e);
        if (!mod) continue;
        const fallbackRaw = mode === COMPETENCY_MODES.ENTRECOMP ? mod.entrecomp : mod.bncc;
        const raw = getEventCompetencyRaw(e, mode) || fallbackRaw;
        if (!raw) continue;
        addCompetencyDistribution(counts, raw, 1);
      }
      return toSortedPairs(counts, limit);
    }

    function collectCompetencyPairsFromItemPairs(itemPairs, mode = COMPETENCY_MODES.BNCC, limit = Number.POSITIVE_INFINITY) {
      const counts = new Map();
      for (const [itemLabel, countRaw] of (itemPairs || [])) {
        const weight = Number(countRaw || 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;
        const mod = resolveModuleByTitle(itemLabel);
        if (!mod) continue;
        const raw = mode === COMPETENCY_MODES.ENTRECOMP ? mod.entrecomp : mod.bncc;
        if (!raw) continue;
        addCompetencyDistribution(counts, raw, weight);
      }
      return toSortedPairs(counts, limit);
    }

    function competencyModeLabel(mode) {
      return mode === COMPETENCY_MODES.ENTRECOMP ? "EntreComp" : "BNCC";
    }

    function isValidUfValue(value) {
      const raw = String(value ?? "").trim();
      if (!raw) return false;
      const compact = normalizeTextKey(raw).replace(/\s+/g, "");
      if (!compact) return false;
      if (compact === "[]" || compact === "[ ]" || compact === "N/A" || compact === "NULL") return false;
      return true;
    }

    function isValidCityValue(value) {
      const raw = String(value ?? "").trim();
      if (!raw) return false;
      const compact = normalizeTextKey(raw).replace(/\s+/g, "");
      if (!compact) return false;
      if (compact === "[]" || compact === "[ ]" || compact === "N/A" || compact === "NA" || compact === "NULL") return false;
      return true;
    }

    function formatUfDisplay(value) {
      return isValidUfValue(value) ? String(value).trim() : "-";
    }

    function normalizeCep(value) {
      const digits = String(value ?? "").replace(/\D/g, "");
      return digits.length === 8 ? digits : "";
    }

    function toFiniteNumberOrNaN(value) {
      if (value === null || value === undefined) return NaN;
      if (typeof value === "string" && !value.trim()) return NaN;
      const n = Number(value);
      return Number.isFinite(n) ? n : NaN;
    }

    function toSentenceCase(value) {
      const s = String(value || "").trim().toLowerCase();
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function isEventoType(value) {
      const k = normalizeTextKey(value);
      return k === "EVENTO" || k.startsWith("EVENTO ");
    }

    function resolveUfCode(value) {
      const raw = String(value || "").trim();
      if (!raw) return "";
      const asCode = raw.toUpperCase();
      if (UF_CENTROIDS[asCode]) return asCode;

      const normalized = normalizeTextKey(raw);
      if (UF_NAME_TO_SIGLA[normalized]) return UF_NAME_TO_SIGLA[normalized];

      const legacySigla = UF_SIGLAS[raw] || UF_SIGLAS[normalized];
      if (legacySigla && UF_CENTROIDS[legacySigla]) return legacySigla;
      return "";
    }

    function mergeUfOptions(...lists) {
      const byCode = new Map();
      const extras = new Set();
      for (const list of lists) {
        for (const raw of (Array.isArray(list) ? list : [])) {
          const uf = String(raw || "").trim();
          if (!isValidUfValue(uf)) continue;
          const code = resolveUfCode(uf);
          if (code) {
            if (!byCode.has(code)) byCode.set(code, uf);
          } else {
            extras.add(uf);
          }
        }
      }
      const merged = [...byCode.values(), ...extras.values()];
      return uniq(merged).sort((a, b) => String(a).localeCompare(String(b), "pt-BR"));
    }

    function resolveUfGeo(value) {
      const code = resolveUfCode(value);
      if (!code || !UF_CENTROIDS[code]) return null;
      return { uf: code, ...UF_CENTROIDS[code] };
    }

    function rowInscritosCount(row) {
      const v = Number(row?.inscritos);
      if (Number.isFinite(v)) return v;
      return normalizeTextKey(row?.type) === "INSCRICAO" ? 1 : 0;
    }

    function computeUfCoverageFromRows(byCityRows, ufFilter = "Todos", options = {}) {
      const selectedCode = resolveUfCode(ufFilter);
      const byUfRows = Array.isArray(options?.byUfRows) ? options.byUfRows : [];
      const metaCoverage = (options?.metaCoverage && typeof options.metaCoverage === "object") ? options.metaCoverage : null;

      if (!selectedCode) {
        const totalUfs = Object.keys(UF_CENTROIDS).length || 27;
        const ufSet = new Set();
        for (const row of byUfRows) {
          const code = resolveUfCode(row?.uf);
          if (!code) continue;
          if (rowInscritosCount(row) <= 0) continue;
          ufSet.add(code);
        }
        let presentUfs = ufSet.size;
        if (!presentUfs && Number.isFinite(Number(metaCoverage?.ufs_com_inscritos))) {
          presentUfs = Number(metaCoverage.ufs_com_inscritos);
        }
        const pct = totalUfs > 0 ? presentUfs / totalUfs : 0;
        return {
          mode: "uf",
          pct,
          present: presentUfs,
          total: totalUfs,
          text: `${fmtPct(pct)} (${fmtInt(presentUfs)}/${fmtInt(totalUfs)})`
        };
      }

      const totalCities = Number(UF_CITY_TOTALS[selectedCode] || 0);
      const cities = new Set();
      for (const row of byCityRows || []) {
        if (resolveUfCode(row?.uf) !== selectedCode) continue;
        if (rowInscritosCount(row) <= 0) continue;
        const city = resolveCityLabelFromRow(row);
        if (!city) continue;
        cities.add(normalizeTextKey(city));
      }
      let presentCities = cities.size;
      if (!presentCities && Number.isFinite(Number(metaCoverage?.cidades_uf_com_inscritos))) {
        presentCities = Number(metaCoverage.cidades_uf_com_inscritos);
      }
      if (!totalCities) {
        return { mode: "city", pct: 0, present: presentCities, total: 0, text: "--" };
      }
      const pct = presentCities / totalCities;
      return {
        mode: "city",
        pct,
        present: presentCities,
        total: totalCities,
        text: `${fmtPct(pct)} (${fmtInt(presentCities)}/${fmtInt(totalCities)})`
      };
    }

    function computeUfCoverageFromEvents(events, ufFilter = "Todos") {
      const selectedCode = resolveUfCode(ufFilter);
      const totalUfs = Object.keys(UF_CENTROIDS).length || 27;

      if (!selectedCode) {
        const ufs = new Set();
        for (const e of events || []) {
          if (normalizeTextKey(e?.type) !== "INSCRICAO") continue;
          const code = resolveUfCode(e?.uf);
          if (code) ufs.add(code);
        }
        const pct = totalUfs > 0 ? ufs.size / totalUfs : 0;
        return { mode: "uf", pct, present: ufs.size, total: totalUfs, text: `${fmtPct(pct)} (${fmtInt(ufs.size)}/${fmtInt(totalUfs)})` };
      }

      const cities = new Set();
      for (const e of events || []) {
        if (normalizeTextKey(e?.type) !== "INSCRICAO") continue;
        if (resolveUfCode(e?.uf) !== selectedCode) continue;
        const city = resolveCityLabelFromRow({ uf: e?.uf, cidade: e?.city, city: e?.city });
        if (!city) continue;
        cities.add(normalizeTextKey(city));
      }
      const totalCities = Number(UF_CITY_TOTALS[selectedCode] || 0);
      if (!totalCities) return { mode: "city", pct: 0, present: cities.size, total: 0, text: "--" };
      const pct = cities.size / totalCities;
      return { mode: "city", pct, present: cities.size, total: totalCities, text: `${fmtPct(pct)} (${fmtInt(cities.size)}/${fmtInt(totalCities)})` };
    }

    function resolveCityLabelFromRow(row) {
      const cityRaw = String(row?.city ?? row?.cidade ?? "").trim();
      const cityCepMatch = cityRaw.match(/^CEP\s*(\d{8})$/i);
      const cepNorm = cityCepMatch ? normalizeCep(cityCepMatch[1]) : normalizeCep(row?.cep);
      if (isValidCityValue(cityRaw) && !cityCepMatch) return cityRaw;
      if (cepNorm) {
        const dict = cepGeoDictionary.get(cepNorm);
        const dictCity = String(dict?.cidade || "").trim();
        if (isValidCityValue(dictCity)) return dictCity;
      }
      return "";
    }

    function aggregateTopCities(rows, limit = 6) {
      const grouped = new Map();
      for (const row of rows || []) {
        const cepNorm = normalizeCep(row?.cep);
        const cityRaw = resolveCityLabelFromRow(row);
        if (!cityRaw) continue;

        const ufRaw = String(row?.uf || "").trim();
        const ufCode = resolveUfCode(ufRaw);
        const uf = ufCode || (isValidUfValue(ufRaw) ? ufRaw : "");
        const weight = Number(row?.weight ?? row?.atendimentos ?? row?.inscritos ?? row?.ativos ?? row?.qtd ?? 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;

        const key = `${uf}|${normalizeTextKey(cityRaw)}`;
        const prev = grouped.get(key);
        if (prev) {
          prev.weight += weight;
          if (!prev.cep && cepNorm) prev.cep = cepNorm;
        } else {
          grouped.set(key, { city: cityRaw, uf, weight, cep: cepNorm || "" });
        }
      }
      return Array.from(grouped.values())
        .sort((a, b) => b.weight - a.weight)
        .slice(0, limit);
    }

    function aggregateCityMetricPairs(rows, selectedUfCode = "", metricKey = "atendimentos", limit = 10) {
      const grouped = new Map();
      for (const row of rows || []) {
        const ufCode = resolveUfCode(row?.uf);
        if (selectedUfCode && ufCode !== selectedUfCode) continue;
        const city = resolveCityLabelFromRow(row);
        if (!city) continue;
        const metric = Number(row?.[metricKey] || 0);
        if (!Number.isFinite(metric) || metric <= 0) continue;
        const label = ufCode ? `${city} (${ufCode})` : city;
        grouped.set(label, Number(grouped.get(label) || 0) + metric);
      }
      return Array.from(grouped.entries())
        .sort((a, b) => {
          const diff = Number(b[1] || 0) - Number(a[1] || 0);
          if (diff !== 0) return diff;
          return String(a[0]).localeCompare(String(b[0]), "pt-BR");
        })
        .slice(0, limit);
    }

    function mapCityFocusKeyFromRow(row) {
      const ufCode = resolveUfCode(row?.uf) || "";
      const city = resolveCityLabelFromRow(row);
      if (city) return `${ufCode}|city:${normalizeTextKey(city)}`;
      if (ufCode) return `${ufCode}|uf`;
      return "";
    }

    function mapCityFocusLabelFromRow(row) {
      const city = resolveCityLabelFromRow(row);
      const ufCode = resolveUfCode(row?.uf);
      if (city && ufCode) return `${city} (${ufCode})`;
      if (city) return city;
      return ufCode || "Local";
    }

    function matchesMapCityFocus(pointKey, focusKey) {
      const point = String(pointKey || "");
      const focus = String(focusKey || "");
      if (!focus) return true;
      if (point === focus) return true;
      if (focus.includes("|city:")) {
        const ufPrefix = String(focus.split("|city:")[0] || "").trim();
        if (ufPrefix) return false;
        const citySuffix = focus.slice(focus.indexOf("|city:"));
        return point.endsWith(citySuffix);
      }
      return false;
    }

    function countDistinctCities(rows) {
      const keys = new Set();
      for (const row of rows || []) {
        const cityRaw = resolveCityLabelFromRow(row);
        if (!cityRaw) continue;
        const ufRaw = String(row?.uf || "").trim();
        const ufCode = resolveUfCode(ufRaw) || ufRaw;
        keys.add(`${ufCode}|${normalizeTextKey(cityRaw)}`);
      }
      return keys.size;
    }

    function ensureDerivedFields(events) {
      for (const e of events) {
        if (e.type === "acao") e.type = "atendimento";
        e.channel = deriveChannel(e);
        e.duration_min = deriveDuration(e);
      }
    }

    // =========================================================
    // Dados (RPC Supabase + fallback mock)
    // =========================================================
    const ENV = window.__ENV || window.__env || window.env || {};
    const MAX_RPC_LIMIT = 200000;
    const RPC_TIMEOUT_MS = 12000;
    const RPC_RETRY_ATTEMPTS = 1;
    const DEV_MOCK_FALLBACK = Boolean(
      window.__USE_MOCK_FALLBACK__ ??
      ENV.USE_MOCK_FALLBACK ??
      (
        location.protocol === "file:" ||
        !location.hostname ||
        location.hostname === "localhost" ||
        location.hostname === "127.0.0.1"
      )
    );

    const SUPABASE_RPC = {
      url: (
        window.__SUPABASE_URL__ ||
        ENV.SUPABASE_URL ||
        ENV.NEXT_PUBLIC_SUPABASE_URL ||
        document.querySelector('meta[name="supabase-url"]')?.content ||
        ""
      ).trim(),
      anonKey: (
        window.__SUPABASE_ANON_KEY__ ||
        ENV.SUPABASE_ANON_KEY ||
        ENV.NEXT_PUBLIC_SUPABASE_ANON_KEY ||
        document.querySelector('meta[name="supabase-anon-key"]')?.content ||
        ""
      ).trim(),
      rpcName: (window.__DASHBOARD_RPC_NAME__ || ENV.DASHBOARD_RPC_NAME || "dashboard_executivo_v1").trim(),
      authMode: String(window.__DASHBOARD_AUTH_MODE__ || ENV.DASHBOARD_AUTH_MODE || "internal").toLowerCase(),
      oauthProvider: String(window.__SUPABASE_OAUTH_PROVIDER__ || ENV.SUPABASE_OAUTH_PROVIDER || "google").toLowerCase(),
      rpcLimit: clamp(Number(window.__RPC_LIMIT__ || ENV.RPC_LIMIT || MAX_RPC_LIMIT), 1, MAX_RPC_LIMIT),
      timeoutMs: clamp(Number(window.__RPC_TIMEOUT_MS__ || ENV.RPC_TIMEOUT_MS || RPC_TIMEOUT_MS), 3000, 30000),
    };
    const AUTH_MODES = new Set(["internal", "public"]);
    if (!AUTH_MODES.has(SUPABASE_RPC.authMode)) SUPABASE_RPC.authMode = "internal";

    let sbClient = null;
    let authSubscription = null;

    /**
     * Formato esperado (exemplo):
     * {
     *   "generated_at": "2026-01-26T00:00:00Z",
     *   "events": [
     *     {
     *       "date": "2025-09-12",
     *       "uf": "Pernambuco",
     *       "city": "Recife",
     *       "lat": -8.05,
     *       "lng": -34.9,
     *       "type": "inscricao" | "atendimento", // "acao" (legado) e tratado como "atendimento"
     *       "publico": "Estudante" | "Professor" | "Parceiro",
     *       "material_type": "E-book" | "Video" | "Material Interativo",
     *       "macrotema": "Autoconhecimento..." | "...",
     *       "user_id": "123",
     *       "actions_total_user": 0
     *     }
     *   ],
     *   "meta": {
     *     "full_range": { "from": "2025-01-01", "to": "2025-12-31" },
     *     "available_ufs": ["Pernambuco", "Ceará"],
     *     "available_publicos": ["Estudante", "Professor"]
     *   }
     * }
     */

    function uniqueSorted(arr) {
      return Array.from(new Set((arr || []).filter(Boolean))).sort();
    }

    function sanitizeFilterValue(v) {
      const s = String(v ?? "").trim();
      return !s || s === "Todos" ? null : s;
    }

    function resolveUfFilterValue(v) {
      const raw = sanitizeFilterValue(v);
      if (!raw) return null;
      const code = resolveUfCode(raw);
      if (!code) return raw;

      if (state?.ufPillsValueByCode instanceof Map) {
        const fromSnapshot = state.ufPillsValueByCode.get(code);
        if (isValidUfValue(fromSnapshot)) return String(fromSnapshot).trim();
      }

      const metaUfs = Array.isArray(state?.raw?.meta?.available_ufs) ? state.raw.meta.available_ufs : [];
      for (const uf of metaUfs) {
        if (resolveUfCode(uf) === code) return String(uf).trim();
      }

      const byUf = Array.isArray(state?.raw?.by_uf) ? state.raw.by_uf : [];
      for (const row of byUf) {
        const uf = row?.uf;
        if (resolveUfCode(uf) === code) return String(uf).trim();
      }

      return UF_CODE_TO_NAME[code] || raw;
    }

    function normalizeDateYmd(v) {
      const s = String(v || "").trim();
      if (!s) return null;
      if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
      return s;
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function isRetryableError(err) {
      const msg = String(err?.message || err || "").toLowerCase();
      return (
        msg.includes("timeout") ||
        msg.includes("rpc_timeout") ||
        msg.includes("network") ||
        msg.includes("failed to fetch") ||
        msg.includes("gateway timeout") ||
        msg.includes("upstream server is timing out") ||
        msg.includes("abort")
      );
    }

    function errorToLog(err) {
      if (!err) return { message: "unknown error" };
      if (typeof err === "string") return { message: err };
      const payload = {
        message: err.message || String(err),
      };
      if (err.code) payload.code = err.code;
      if (err.details) payload.details = err.details;
      if (err.hint) payload.hint = err.hint;
      if (err.status) payload.status = err.status;
      return payload;
    }

    function initSupabaseClient() {
      if (sbClient) return sbClient;
      if (!window.supabase || typeof window.supabase.createClient !== "function") {
        throw new Error("Biblioteca supabase-js indisponivel.");
      }
      if (!SUPABASE_RPC.url || !SUPABASE_RPC.anonKey) {
        throw new Error("SUPABASE_URL ou SUPABASE_ANON_KEY nao configurados.");
      }
      sbClient = window.supabase.createClient(SUPABASE_RPC.url, SUPABASE_RPC.anonKey, {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
        }
      });
      console.info("[UI] [auth] supabase client initialized", {
        mode: SUPABASE_RPC.authMode,
        rpc: SUPABASE_RPC.rpcName
      });
      return sbClient;
    }

    function getRpcParams(filters) {
      let from = normalizeDateYmd(filters?.dateFrom);
      let to = normalizeDateYmd(filters?.dateTo);
      if (from && to && from > to) {
        const tmp = from;
        from = to;
        to = tmp;
      }
      return {
        p_date_from: from,
        p_date_to: to,
        p_uf: resolveUfFilterValue(filters?.uf),
        p_publico: sanitizeFilterValue(filters?.publico),
        p_limit: SUPABASE_RPC.rpcLimit,
      };
    }

    function normalizeAndValidateEvents(events) {
      if (!Array.isArray(events)) return [];
      const normalized = [];
      let invalid = 0;
      for (const e of events) {
        const hasBaseFields = Boolean(
          e &&
          normalizeDateYmd(e.date) &&
          e.uf &&
          e.type &&
          e.publico &&
          e.user_id
        );
        if (!hasBaseFields) {
          invalid++;
          continue;
        }
        normalized.push({
          ...e,
          date: normalizeDateYmd(e.date),
        });
      }
      if (invalid) {
        console.warn("[UI] [data] events with invalid shape were dropped", { invalid });
      }
      return normalized;
    }

    function isAggregatedPayload(payload) {
      return Boolean(
        payload &&
        typeof payload === "object" &&
        payload.kpis &&
        Array.isArray(payload.series_daily) &&
        Array.isArray(payload.by_uf) &&
        Array.isArray(payload.by_publico)
      );
    }

    function ensurePayloadMeta(payload, context = {}) {
      const metaRaw = (payload && typeof payload.meta === "object" && payload.meta) ? payload.meta : {};
      const events = normalizeAndValidateEvents(payload?.events);
      const dates = uniqueSorted(events.map((e)=>e.date));
      const requestedLimit = clamp(Number(context.limit || SUPABASE_RPC.rpcLimit || MAX_RPC_LIMIT), 1, MAX_RPC_LIMIT);

      const fullRange = (metaRaw.full_range && typeof metaRaw.full_range === "object")
        ? {
            from: String(metaRaw.full_range.from || ""),
            to: String(metaRaw.full_range.to || "")
          }
        : { from: "", to: "" };

      if ((!fullRange.from || !fullRange.to) && dates.length) {
        fullRange.from = dates[0];
        fullRange.to = dates[dates.length - 1];
      }
      const isTruncated = typeof metaRaw.truncated === "boolean"
        ? metaRaw.truncated
        : events.length >= requestedLimit;

      return {
        ...payload,
        generated_at: payload?.generated_at || new Date().toISOString(),
        events,
        meta: {
          ...metaRaw,
          full_range: fullRange,
          available_ufs: Array.isArray(metaRaw.available_ufs) && metaRaw.available_ufs.length
            ? uniqueSorted(metaRaw.available_ufs)
            : (
                Array.isArray(payload?.by_uf) && payload.by_uf.length
                  ? uniqueSorted(payload.by_uf.map((x)=>x.uf))
                  : uniqueSorted(events.map((e)=>e.uf))
              ),
          available_publicos: Array.isArray(metaRaw.available_publicos) && metaRaw.available_publicos.length
            ? uniqueSorted(metaRaw.available_publicos)
            : (
                Array.isArray(payload?.by_publico) && payload.by_publico.length
                  ? uniqueSorted(payload.by_publico.map((x)=>x.publico))
                  : uniqueSorted(events.map((e)=>e.publico))
              ),
          cap: {
            limit: requestedLimit,
            returned: Number(metaRaw?.cap?.returned ?? events.length ?? 0),
            truncated: isTruncated,
          },
        }
      };
    }

    function validatePayloadShape(payload) {
      if (!payload || typeof payload !== "object") {
        throw new Error("Payload invalido: esperado objeto.");
      }
      if (!payload.generated_at) {
        throw new Error("Payload invalido: campo 'generated_at' ausente.");
      }
      if (isAggregatedPayload(payload)) return;
      if (!Array.isArray(payload.events)) {
        throw new Error("Payload invalido: esperado 'events[]' ou payload agregado (kpis/series_daily/by_uf/by_publico).");
      }
    }

    let mockDatasetCache = null;

    function buildMockData() {
      console.warn("[UI] [data] using mock data");
      const ufsNE = ["Maranhão","Piauí","Ceará","Rio Grande do Norte","Paraíba","Pernambuco","Alagoas","Sergipe","Bahia"];
      const cities = {
        "Pernambuco": [{c:"Recife",lat:-8.05,lng:-34.9},{c:"Caruaru",lat:-8.28,lng:-35.98}],
        "Ceará": [{c:"Fortaleza",lat:-3.73,lng:-38.52},{c:"Juazeiro do Norte",lat:-7.21,lng:-39.31}],
        "Maranhão": [{c:"São Luís",lat:-2.53,lng:-44.30},{c:"Imperatriz",lat:-5.52,lng:-47.48}],
        "Bahia": [{c:"Salvador",lat:-12.97,lng:-38.51},{c:"Feira de Santana",lat:-12.26,lng:-38.96}],
        "Paraíba": [{c:"João Pessoa",lat:-7.12,lng:-34.86},{c:"Campina Grande",lat:-7.23,lng:-35.88}],
        "Piauí": [{c:"Teresina",lat:-5.09,lng:-42.80}],
        "Rio Grande do Norte": [{c:"Natal",lat:-5.79,lng:-35.21}],
        "Alagoas": [{c:"Maceió",lat:-9.65,lng:-35.71}],
        "Sergipe": [{c:"Aracaju",lat:-10.91,lng:-37.07}],
      };
      const material = ["E-book","Vídeo","Material Interativo"];
      const publico = ["Estudante","Professor","Parceiro"];
      const channels = CHANNELS;
      const modulePool = MODULE_CATALOG_ENRICHED
        .filter((mod) => String(mod?.macrotemaId || "").trim())
        .map((mod) => ({
        title: mod.title,
        macrotema: MACROTEMA_CATALOG[mod.macrotemaId]?.title || mod.macrotemaId,
        bncc: mod.bncc,
        entrecomp: mod.entrecomp,
        trail: mod.trail || "",
      }));

      const start = new Date("2025-04-01T00:00:00Z");
      const end = new Date("2025-12-31T00:00:00Z");

      const dayMs = 24*60*60*1000;

      // usuarios mock
      const users = Array.from({length: 15000}, (_, i) => ({
        id: String(100000 + i),
        actions_total_user: Math.floor(Math.random()*6), // 0..5
        publico: publico[Math.floor(Math.random()*publico.length)]
      }));

      function pickUF() {
        // favorece alguns estados para simular concentracao
        const r = Math.random();
        if (r < 0.22) return "Pernambuco";
        if (r < 0.38) return "Ceará";
        if (r < 0.50) return "Maranhão";
        if (r < 0.60) return "Bahia";
        return ufsNE[Math.floor(Math.random()*ufsNE.length)];
      }

      const events = [];
      const totalEvents = 110000; // suficiente p/ graficos e tabelas
      for (let i=0; i<totalEvents; i++) {
        const t = start.getTime() + Math.floor(Math.random()*((end.getTime()-start.getTime())/dayMs))*dayMs;
        const d = new Date(t);
        const date = d.toISOString().slice(0,10);

        const uf = pickUF();
        const cityOptions = cities[uf] || [{c:"",lat:-10,lng:-45}];
        const cityPick = cityOptions[Math.floor(Math.random()*cityOptions.length)];

        const u = users[Math.floor(Math.random()*users.length)];
        const typeRoll = Math.random();
        const type = typeRoll < 0.22 ? "inscricao" : "atendimento";

        const modulePick = modulePool[Math.floor(Math.random() * modulePool.length)];
        events.push({
          date,
          uf,
          city: cityPick.c,
          lat: cityPick.lat + (Math.random()-0.5)*0.12,
          lng: cityPick.lng + (Math.random()-0.5)*0.12,
          type,
          publico: u.publico,
          material_type: material[Math.floor(Math.random()*material.length)],
          macrotema: modulePick.macrotema,
          nome_item: modulePick.title,
          modulo: modulePick.title,
          bncc: modulePick.bncc,
          entrecomp: modulePick.entrecomp,
          trail: modulePick.trail,
          channel: channels[Math.floor(Math.random()*channels.length)],
          duration_min: 10 + Math.floor(Math.random()*50),
          user_id: u.id,
          actions_total_user: u.actions_total_user,
        });
      }

      const dates = uniqueSorted(events.map((e)=>e.date));
      return ensurePayloadMeta({
        generated_at: new Date().toISOString(),
        events,
        meta: {
          full_range: {
            from: dates[0] || "",
            to: dates[dates.length - 1] || ""
          },
          available_ufs: uniqueSorted(events.map((e)=>e.uf)),
          available_publicos: uniqueSorted(events.map((e)=>e.publico)),
        }
      }, { limit: SUPABASE_RPC.rpcLimit });
    }

    function getMockPayloadForFilters(filters) {
      if (!mockDatasetCache) {
        mockDatasetCache = ensurePayloadMeta(buildMockData());
      }

      const params = getRpcParams(filters);
      const dateFiltered = mockDatasetCache.events.filter((e) => {
        if (params.p_date_from && e.date < params.p_date_from) return false;
        if (params.p_date_to && e.date > params.p_date_to) return false;
        return true;
      });

      const filtered = dateFiltered.filter((e) => {
        if (params.p_uf && e.uf !== params.p_uf) return false;
        if (params.p_publico && e.publico !== params.p_publico) return false;
        return true;
      });

      let prevRange = null;
      let previousKpis = null;
      if (params.p_date_from && params.p_date_to) {
        const days = diffDaysInclusive(params.p_date_from, params.p_date_to);
        if (days) {
          const prevTo = shiftDate(params.p_date_from, -1);
          const prevFrom = shiftDate(params.p_date_from, -days);
          const prevEvents = mockDatasetCache.events.filter((e) => {
            if (e.date < prevFrom || e.date > prevTo) return false;
            if (params.p_uf && e.uf !== params.p_uf) return false;
            if (params.p_publico && e.publico !== params.p_publico) return false;
            return true;
          });

          let atend = 0;
          let inscr = 0;
          const usersInscritos = new Set();
          const usersAtendidos = new Set();
          for (const e of prevEvents) {
            if (e.type === "atendimento" || e.type === "acao") {
              atend++;
              if (e.user_id) usersAtendidos.add(e.user_id);
            }
            if (e.type === "inscricao") {
              inscr++;
              if (e.user_id) usersInscritos.add(e.user_id);
            }
          }
          previousKpis = {
            atendimentos: atend,
            inscricoes: inscr,
            inscritos: usersInscritos.size,
            conversaoAtendimento: usersInscritos.size ? (usersAtendidos.size / usersInscritos.size) : 0,
          };
          prevRange = { from: prevFrom, to: prevTo };
        }
      }

      return ensurePayloadMeta({
        generated_at: new Date().toISOString(),
        events: filtered,
        meta: {
          full_range: mockDatasetCache.meta?.full_range || { from: "", to: "" },
          available_ufs: uniqueSorted(dateFiltered.map((e)=>e.uf)),
          available_publicos: uniqueSorted(dateFiltered.map((e)=>e.publico)),
          previous_range: prevRange,
          previous_kpis: previousKpis,
        }
      }, { limit: SUPABASE_RPC.rpcLimit });
    }

    function setAuthGate(visible, message = "Faça login para acessar o dashboard.") {
      const gate = document.getElementById("authGate");
      const msg = document.getElementById("authGateMessage");
      if (msg) msg.textContent = message;
      if (!gate) return;
      gate.classList.toggle("hidden", !visible);
    }

    async function startAuthLogin() {
      if (!sbClient) return;
      const { error } = await sbClient.auth.signInWithOAuth({
        provider: SUPABASE_RPC.oauthProvider,
        options: { redirectTo: location.href }
      });
      if (error) {
        console.error("[UI] [auth] oauth failed", { err: String(error) });
        showToast("Falha ao iniciar login.", "warning");
      }
    }

    function bindAuthEvents() {
      const btnAuth = document.getElementById("btnAuthLogin");
      if (btnAuth && !btnAuth.dataset.bound) {
        btnAuth.dataset.bound = "1";
        btnAuth.addEventListener("click", () => {
          startAuthLogin().catch((e)=>console.error("[UI] [auth] login failed", { err: String(e) }));
        });
      }
      if (!sbClient || SUPABASE_RPC.authMode !== "internal" || authSubscription) return;
      const sub = sbClient.auth.onAuthStateChange((event, session) => {
        state.session = session || null;
        console.info("[UI] [auth] state changed", { event, hasSession: Boolean(session) });
        if (state.session) {
          setAuthGate(false);
          applyFilters({}, { immediate: true, reason: `auth-${event}`, showLoadingToast: false });
        } else {
          setAuthGate(true, "Faça login para carregar os dados do dashboard.");
        }
      });
      authSubscription = sub?.data?.subscription || null;
    }

    async function ensureAuthSession() {
      if (SUPABASE_RPC.authMode !== "internal") return true;
      if (!sbClient) throw new Error("Cliente Supabase nao inicializado.");
      const { data, error } = await sbClient.auth.getSession();
      if (error) throw error;
      state.session = data?.session || null;
      if (!state.session) {
        setAuthGate(true, "Faça login para acessar os dados executivos.");
        return false;
      }
      setAuthGate(false);
      return true;
    }

    async function callDashboardRpc(params) {
      if (!sbClient) throw new Error("Cliente Supabase indisponivel.");
      const controller = new AbortController();
      const timeoutError = new Error(`RPC timeout (${SUPABASE_RPC.timeoutMs}ms)`);
      timeoutError.code = "RPC_TIMEOUT";

      let timeoutHandle = null;
      const timeoutOperation = new Promise((_, reject) => {
        timeoutHandle = setTimeout(() => {
          try { controller.abort(); } catch (_) {}
          reject(timeoutError);
        }, SUPABASE_RPC.timeoutMs);
      });

      const rpcOperation = (async () => {
        let req = sbClient.rpc(SUPABASE_RPC.rpcName, params);
        if (req && typeof req.abortSignal === "function") {
          req = req.abortSignal(controller.signal);
        }
        const { data, error } = await req;
        if (error) throw error;
        return data;
      })();

      try {
        return await Promise.race([rpcOperation, timeoutOperation]);
      } finally {
        if (timeoutHandle) clearTimeout(timeoutHandle);
      }
    }

    async function callDashboardRpcWithRetry(params) {
      let attempt = 0;
      while (attempt <= RPC_RETRY_ATTEMPTS) {
        try {
          return await callDashboardRpc(params);
        } catch (e) {
          attempt += 1;
          if (attempt > RPC_RETRY_ATTEMPTS || !isRetryableError(e)) throw e;
          console.warn("[UI] [data] rpc retry", { attempt, err: errorToLog(e) });
          await wait(350 * attempt);
        }
      }
      throw new Error("RPC failed after retries.");
    }

    async function loadData() {
      const params = getRpcParams(state.filters);
      const t0 = performance.now();
      const hasRpcConfig = Boolean(SUPABASE_RPC.url && SUPABASE_RPC.anonKey);

      console.debug("[UI] [data] load:start", {
        mode: hasRpcConfig ? "rpc" : "mock",
        rpc: SUPABASE_RPC.rpcName,
        auth_mode: SUPABASE_RPC.authMode,
        host: location.host,
        filters: { ...state.filters },
        params
      });

      if (!hasRpcConfig) {
        if (!DEV_MOCK_FALLBACK) {
          throw new Error("Configuração Supabase ausente e fallback mock desabilitado.");
        }
        state.lastDataWarning = "RPC Supabase nao configurado. Exibindo dados mock (dev).";
        state.lastLoadSource = "mock";
        return getMockPayloadForFilters(state.filters);
      }

      if (!sbClient) {
        try {
          initSupabaseClient();
        } catch (e) {
          const logFn = DEV_MOCK_FALLBACK ? console.warn : console.error;
          logFn("[UI] [auth] failed to init client", { err: String(e) });
          if (!DEV_MOCK_FALLBACK) throw e;
          state.lastDataWarning = "Falha ao iniciar Supabase client. Exibindo dados mock (dev).";
          state.lastLoadSource = "mock";
          return getMockPayloadForFilters(state.filters);
        }
      }

      if (SUPABASE_RPC.authMode === "internal") {
        const allowed = await ensureAuthSession();
        if (!allowed) throw new Error("AUTH_REQUIRED");
      }

      console.debug("[UI] [data] rpc:request", { rpc: SUPABASE_RPC.rpcName, params });
      try {
        const result = await callDashboardRpcWithRetry(params);
        const payload = Array.isArray(result) ? result[0] : result;
        validatePayloadShape(payload);
        const normalized = ensurePayloadMeta(payload, { limit: params.p_limit });
        state.lastDataWarning = "";
        state.lastLoadSource = "rpc";
        console.info("[UI] [data] rpc:ok", {
          ms: Math.round(performance.now() - t0),
          events: normalized.events.length,
          generated_at: normalized.generated_at
        });
        return normalized;
      } catch (e) {
        console.error("[UI] [data] rpc:fail", { err: errorToLog(e), params });
        if (!DEV_MOCK_FALLBACK) {
          throw e;
        }
        state.lastDataWarning = "Falha ao consultar RPC Supabase. Exibindo dados mock (dev).";
        state.lastLoadSource = "mock";
        return getMockPayloadForFilters(state.filters);
      }
    }

    // =========================================================
    // Estado + filtros
    // =========================================================
    const state = {
      page: "overview",
      raw: null,
      filtered: [],
      summaryText: "",
      fullRange: { from: "", to: "" },
      toastTimer: null,
      refreshDebounceTimer: null,
      requestSeq: 0,
      isLoading: false,
      lastDataWarning: "",
      lastLoadSource: "none",
      ufPillsCountsByCode: new Map(),
      ufPillsValueByCode: new Map(),
      session: null,
      mapCityFocus: null,
      ufOnboardingUnlocked: false,
      competencyMode: COMPETENCY_MODES.BNCC,
      filters: {
        dateFrom: "",
        dateTo: "",
        uf: "Todos",
        publico: "Todos",
      }
    };

    function syncCompetencyModeControls() {
      const mode = state.competencyMode === COMPETENCY_MODES.ENTRECOMP
        ? COMPETENCY_MODES.ENTRECOMP
        : COMPETENCY_MODES.BNCC;
      const bnccButtons = ["btnCompModeBncc", "btnCompModeBnccContent"];
      const entrecompButtons = ["btnCompModeEntrecomp", "btnCompModeEntrecompContent"];
      for (const id of bnccButtons) {
        const btn = document.getElementById(id);
        if (btn) btn.classList.toggle("is-active", mode === COMPETENCY_MODES.BNCC);
      }
      for (const id of entrecompButtons) {
        const btn = document.getElementById(id);
        if (btn) btn.classList.toggle("is-active", mode === COMPETENCY_MODES.ENTRECOMP);
      }
    }

    function setCompetencyMode(nextMode) {
      const normalized = nextMode === COMPETENCY_MODES.ENTRECOMP
        ? COMPETENCY_MODES.ENTRECOMP
        : COMPETENCY_MODES.BNCC;
      if (state.competencyMode === normalized) {
        syncCompetencyModeControls();
        return;
      }
      state.competencyMode = normalized;
      syncCompetencyModeControls();
      renderCompetencyWrappers();
    }

    function getCurrentCompetencyPairs() {
      if (isAggregatedPayload(state.raw)) {
        const topItensRows = Array.isArray(state.raw?.top_itens) ? state.raw.top_itens : [];
        const topItens = topItensRows.map((r) => [String(r.nome_item || "N/A"), Number(r.qtd || 0)]);
        const rawPairs = collectCompetencyPairsFromItemPairs(topItens, state.competencyMode);
        return toPercentagePairs(rawPairs, 10);
      }
      const rawPairs = collectCompetencyPairsFromEvents(state.filtered, state.competencyMode);
      return toPercentagePairs(rawPairs, 10);
    }

    function renderCompetencyWrappers() {
      const competencyPairs = getCurrentCompetencyPairs();
      const topCompetency = competencyPairs[0];
      const topLabel = document.getElementById("competencyTopLabel");
      if (topLabel) {
        topLabel.textContent = topCompetency
          ? `${topCompetency[0]} (${fmtPct(Number(topCompetency[1] || 0) / 100)})`
          : "-";
      }

      if (state.page === "overview") {
        renderDoughnut(
          "chartMaterial",
          competencyPairs,
          `Competências (${competencyModeLabel(state.competencyMode)})`,
          { percentMode: true }
        );
      }

      if (state.page === "content") {
        renderDoughnut(
          "chartMatBar",
          competencyPairs,
          `Competências (${competencyModeLabel(state.competencyMode)})`,
          { percentMode: true }
        );
      }
    }

    function showToast(message, tone = "info") {
      const toast = document.getElementById("toast");
      if (!toast) return;
      toast.textContent = message;
      toast.classList.remove("hidden", "bg-emerald-100", "text-emerald-900", "border-emerald-300", "bg-fuchsia-100", "text-fuchsia-900", "border-fuchsia-300", "bg-blue-100", "text-blue-900", "border-blue-300");
      if (tone === "success") {
        toast.classList.add("bg-emerald-100", "text-emerald-900", "border-emerald-300");
      } else if (tone === "warning") {
        toast.classList.add("bg-fuchsia-100", "text-fuchsia-900", "border-fuchsia-300");
      } else {
        toast.classList.add("bg-blue-100", "text-blue-900", "border-blue-300");
      }
      clearTimeout(state.toastTimer);
      state.toastTimer = setTimeout(() => toast.classList.add("hidden"), 2400);
    }

    function setBootLoadingGate(visible, message = "Aguardando retorno do banco de dados...") {
      const gate = document.getElementById("bootLoadingGate");
      const msg = document.getElementById("bootLoadingMessage");
      if (msg) msg.textContent = message;
      if (!gate) return;
      gate.classList.toggle("hidden", !visible);
    }

    function syncFilterForm() {
      const fFrom = document.getElementById("fFrom");
      const fTo = document.getElementById("fTo");
      const fUf = document.getElementById("fUf");
      const fPublico = document.getElementById("fPublico");
      if (fFrom) fFrom.value = state.filters.dateFrom || "";
      if (fTo) fTo.value = state.filters.dateTo || "";
      if (fUf) fUf.value = state.filters.uf || "Todos";
      if (fPublico) fPublico.value = state.filters.publico || "Todos";
    }

    function updateBootError(message = "") {
      const bootError = document.getElementById("bootError");
      if (!bootError) return;
      if (!message) {
        bootError.classList.add("hidden");
        return;
      }
      bootError.textContent = message;
      bootError.classList.remove("hidden");
    }

    function setLoadingState(isLoading) {
      state.isLoading = isLoading;
      const ids = [
        "btnOpenFilters",
        "btnApplyFilters",
        "btnResetFilters",
        "btnExportCsv",
        "btnPreset30",
        "btnPreset90",
        "btnPresetAll",
        "btnClearUf",
        "btnCompModeBncc",
        "btnCompModeEntrecomp",
        "btnCompModeBnccContent",
        "btnCompModeEntrecompContent",
        "btnBootLoadingRetry"
      ];
      for (const id of ids) {
        const el = document.getElementById(id);
        if (el) el.disabled = isLoading;
      }
      const app = document.getElementById("app");
      if (app) app.setAttribute("aria-busy", isLoading ? "true" : "false");
    }

    function applyMetaFromPayload(payload) {
      const meta = payload?.meta && typeof payload.meta === "object" ? payload.meta : {};
      const fullRange = meta.full_range && typeof meta.full_range === "object" ? meta.full_range : {};
      const from = String(fullRange.from || "");
      const to = String(fullRange.to || "");
      if (from && to) {
        state.fullRange.from = from;
        state.fullRange.to = to;
        if (!state.filters.dateFrom || state.filters.dateFrom < from) state.filters.dateFrom = from;
        if (!state.filters.dateTo || state.filters.dateTo > to) state.filters.dateTo = to;
        if (state.filters.dateFrom > state.filters.dateTo) state.filters.dateFrom = from;
      }
    }

    async function refreshFromServer(options = {}) {
      const { reason = "filters", showLoadingToast = true } = options;
      const requestId = ++state.requestSeq;

      setLoadingState(true);
      setBootLoadingGate(true, "Carregando dados mais recentes...");
      if (showLoadingToast) showToast("Carregando dados...", "info");
      console.debug("[UI] [data] refresh:start", { requestId, reason, filters: { ...state.filters } });

      try {
        const payload = await loadData();
        if (requestId !== state.requestSeq) {
          console.debug("[UI] [data] refresh:stale response ignored", { requestId });
          return;
        }

        state.raw = payload;
        state.filtered = Array.isArray(payload.events) ? payload.events : [];
        state.mapCityFocus = null;
        ensureDerivedFields(state.filtered);
        applyMetaFromPayload(payload);
        updateUfPillsSnapshot(payload);
        fillFilterOptions();
        syncFilterForm();

        if (state.lastDataWarning) {
          updateBootError(state.lastDataWarning);
        } else {
          updateBootError("");
        }

        try {
          render();
        } catch (renderErr) {
          console.error("[UI] [render] failed after refresh", { requestId, reason, err: String(renderErr) });
          updateBootError("Dados carregados, mas houve falha ao renderizar parte do painel.");
        }
        console.info("[UI] [data] refresh:done", {
          requestId,
          reason,
          events: state.filtered.length,
          generated_at: state.raw?.generated_at,
          full_range: state.raw?.meta?.full_range || null,
          available_ufs: state.raw?.meta?.available_ufs?.length || 0,
          available_publicos: state.raw?.meta?.available_publicos?.length || 0,
        });
      } catch (e) {
        console.error("[UI] [data] refresh:failed", { requestId, reason, err: String(e) });
        if (String(e?.message || e) === "AUTH_REQUIRED") {
          setBootLoadingGate(false);
          updateBootError("Acesso restrito. Faça login para consultar os dados.");
          setAuthGate(true, "Faça login para acessar os dados executivos.");
        } else {
          updateBootError("Falha ao atualizar dados do dashboard. Verifique a conexao e tente novamente.");
        }
        return false;
      } finally {
        if (requestId === state.requestSeq) {
          setLoadingState(false);
          setBootLoadingGate(false);
        }
      }
      return true;
    }

    function scheduleRefreshFromServer(options = {}) {
      const wait = options.immediate ? 0 : (options.debounceMs ?? 380);
      clearTimeout(state.refreshDebounceTimer);
      state.refreshDebounceTimer = setTimeout(() => {
        refreshFromServer(options).catch((e) => {
          console.error("[UI] [data] debounced refresh failed", { err: String(e) });
        });
      }, wait);
    }

    function applyFilters(nextFilters = {}, options = {}) {
      if (nextFilters && Object.keys(nextFilters).length) {
        state.mapCityFocus = null;
      }
      state.filters = { ...state.filters, ...nextFilters };
      syncFilterForm();
      console.debug("[UI] [filters] updated", {
        reason: options.reason || "user",
        filters: { ...state.filters }
      });
      scheduleRefreshFromServer(options);
    }

    // =========================================================
    // Agregacoes
    // =========================================================
    function uniq(arr) { return Array.from(new Set(arr)).sort(); }

    function aggKpis(events) {
      // totais
      let atend = 0, inscr = 0;
      const usersInscritos = new Set();
      const usersAtendidos = new Set();
      const usersAny = new Set();

      for (const e of events) {
        usersAny.add(e.user_id);
        if (e.type === "atendimento") {
          atend++;
          usersAtendidos.add(e.user_id);
        }
        if (e.type === "inscricao") {
          inscr++;
          usersInscritos.add(e.user_id);
        }
      }

      const conv = usersInscritos.size ? (usersAtendidos.size / usersInscritos.size) : 0;

      return {
        atendimentos: atend,
        inscricoes: inscr,
        usersAny: usersAny.size,
        inscritos: usersInscritos.size,
        atendidos: usersAtendidos.size,
        conversaoAtendimento: conv
      };
    }

    function seriesByDate(events, type) {
      const m = new Map();
      for (const e of events) {
        if (type && e.type !== type) continue;
        m.set(e.date, (m.get(e.date)||0)+1);
      }
      const labels = Array.from(m.keys()).sort();
      return { labels, values: labels.map(d => m.get(d)) };
    }

    function topByKey(events, key, whereFn = null, limit = 10) {
      const m = new Map();
      for (const e of events) {
        if (whereFn && !whereFn(e)) continue;
        const k = e[key] ?? "N/A";
        m.set(k, (m.get(k)||0)+1);
      }
      return Array.from(m.entries()).sort((a,b)=>b[1]-a[1]).slice(0,limit);
    }

    function topByCombo(events, keyA, keyB, limit = 5) {
      const m = new Map();
      for (const e of events) {
        const a = e[keyA] ?? "N/A";
        const b = e[keyB] ?? "N/A";
        const k = `${a} | ${b}`;
        m.set(k, (m.get(k)||0)+1);
      }
      return Array.from(m.entries()).sort((a,b)=>b[1]-a[1]).slice(0,limit);
    }

    function shareConcentration(sortedPairs) {
      const total = sortedPairs.reduce((s, [,v])=>s+v, 0) || 1;
      const top3 = sortedPairs.slice(0,3).reduce((s, [,v])=>s+v, 0);
      const top5 = sortedPairs.slice(0,5).reduce((s, [,v])=>s+v, 0);
      return { total, top3: top3/total, top5: top5/total };
    }

    function insights(events) {
      const k = aggKpis(events);

      const byUfAt = topByKey(events, "uf", (e)=>e.type==="atendimento" && isValidUfValue(e.uf), 10);
      const conc = shareConcentration(byUfAt);

      const macroTop = topByKey(events, "macrotema", (e)=>!isEventoType(e.type), 5);
      const matTop = topByKey(events, "material_type", null, 5);

      // crescimento simples: compara ultimos 30 dias vs 30 anteriores (se houver)
      const dates = seriesByDate(events, "inscricao").labels;
      let growth = null;
      if (dates.length >= 60) {
        const last30 = new Set(dates.slice(-30));
        const prev30 = new Set(dates.slice(-60, -30));
        let a=0,b=0;
        for (const e of events) {
          if (e.type !== "inscricao") continue;
          if (last30.has(e.date)) a++;
          if (prev30.has(e.date)) b++;
        }
        growth = b ? (a-b)/b : null;
      }

      const flags = [];
      if (conc.top5 > 0.70) flags.push("Concentracao alta: 5 UFs lideres somam " + fmtPct(conc.top5) + " dos atendimentos.");
      if (k.conversaoAtendimento < 0.20) flags.push("Conversao inscrito->atendido baixa: " + fmtPct(k.conversaoAtendimento) + " (oportunidade de reforcar jornada).");
      if (growth !== null) flags.push("Variacao recente de inscricoes (30d vs 30d anteriores): " + (growth>=0?"+":"") + fmtPct(growth));

      return {
        kpis: k,
        byUfAt,
        macroTop,
        matTop,
        flags
      };
    }

    function seriesStats(labels, values) {
      const total = values.reduce((s, v)=>s+v, 0);
      const maxVal = values.length ? Math.max(...values) : 0;
      const maxIdx = values.indexOf(maxVal);
      return {
        total,
        avg: values.length ? total / values.length : 0,
        maxVal,
        maxLabel: labels[maxIdx] || "—"
      };
    }

    function computeCoverage(events) {
      const ufs = new Set();
      const cities = new Set();
      const dates = new Set();
      const users = new Set();
      const userActions = new Map();
      let atendCount = 0;

      for (const e of events) {
        if (isValidUfValue(e.uf)) ufs.add(e.uf);
        if (e.city && isValidUfValue(e.uf)) cities.add(`${e.uf}|${e.city}`);
        if (e.date) dates.add(e.date);
        if (e.user_id) users.add(e.user_id);
        if (e.type === "atendimento") atendCount++;
        const actions = Number(e.actions_total_user || 0);
        if (e.user_id) {
          const prev = userActions.get(e.user_id) || 0;
          if (actions > prev) userActions.set(e.user_id, actions);
        }
      }

      let actionsSum = 0;
      for (const v of userActions.values()) actionsSum += v;

      const days = dates.size || 1;
      return {
        ufs: ufs.size,
        cities: cities.size,
        days: dates.size,
        users: users.size,
        atendPerDay: atendCount / days,
        avgActions: userActions.size ? actionsSum / userActions.size : 0
      };
    }

    function computeDataQuality(events) {
      const total = events.length || 1;
      let withCity = 0;
      let withCoords = 0;
      let withMacro = 0;
      let withMaterial = 0;
      let dupes = 0;
      const seen = new Set();

      for (const e of events) {
        if (e.city) withCity++;
        if (Number.isFinite(e.lat) && Number.isFinite(e.lng)) withCoords++;
        if (e.macrotema) withMacro++;
        if (e.material_type) withMaterial++;
        const key = `${e.user_id || ""}|${e.date || ""}|${e.type || ""}|${e.macrotema || ""}`;
        if (seen.has(key)) dupes++;
        else seen.add(key);
      }

      return {
        completeness: (withCity + withCoords + withMacro + withMaterial) / (4 * total),
        geocoverage: withCoords / total,
        dupRate: dupes / total
      };
    }

    function buildSummary(events, competencyMode = COMPETENCY_MODES.BNCC) {
      const k = aggKpis(events);
      const byUf = topByKey(events, "uf", (e)=>e.type==="atendimento" && isValidUfValue(e.uf), 3);
      const topUf = byUf[0];
      const macroTop = collectMacrotemaPairsFromEvents(events, 1)[0];
      const competencyTop = collectCompetencyPairsFromEvents(events, competencyMode, 1)[0];
      const channelTop = topByKey(events, "channel", null, 1)[0];

      const days = uniq(events.map(e=>e.date)).length || 1;
      const atendPerDay = k.atendimentos / days;
      const conv = k.conversaoAtendimento;

      return [
        `Volume do periodo: ${fmtInt(k.atendimentos)} atendimentos e ${fmtInt(k.inscricoes)} inscricoes, com ${fmtInt(k.inscritos)} inscritos.`,
        `UF lider: ${topUf ? `${topUf[0]} (${fmtInt(topUf[1])})` : "—"}; media de ${fmtInt(Math.round(atendPerDay))} atendimentos/dia.`,
        `Preferencia: ${macroTop ? macroTop[0] : "—"} e ${competencyModeLabel(competencyMode)} ${competencyTop ? competencyTop[0] : "—"}. Canal dominante: ${channelTop ? channelTop[0] : "—"}. Conversao inscrito->atendido em ${fmtPct(conv)}.`
      ];
    }

    function computePreviousKpis() {
      const prev = state.raw?.meta?.previous_kpis;
      if (!prev || typeof prev !== "object") return null;
      return {
        range: state.raw?.meta?.previous_range || null,
        kpis: {
          atendimentos: Number(prev.atendimentos || 0),
          inscricoes: Number(prev.inscricoes || 0),
          inscritos: Number(prev.inscritos || 0),
          conversaoAtendimento: Number(prev.conversaoAtendimento || 0),
        }
      };
    }

    function formatDelta(current, previous) {
      if (!previous || previous <= 0) return { text: "—", cls: "" };
      const delta = (current - previous) / previous;
      const sign = delta >= 0 ? "+" : "";
      return {
        text: `${sign}${fmtPct(delta)} vs periodo anterior`,
        cls: delta >= 0 ? "positive" : "negative"
      };
    }

    function updateDeltaEl(id, current, previous) {
      const el = document.getElementById(id);
      if (!el) return;
      const { text, cls } = formatDelta(current, previous);
      el.textContent = text;
      el.classList.remove("positive", "negative");
      if (cls) el.classList.add(cls);
    }

    function updateProgress(barId, value, target) {
      const el = document.getElementById(barId);
      if (!el) return;
      const pct = target ? clamp((value / target) * 100, 0, 100) : 0;
      el.style.width = `${pct}%`;
    }

    // =========================================================
    // UI: charts + map
    // =========================================================
    const chartPalette = ["#2A4FDA", "#00D95D", "#FF00FF", "#00F9FF", "#122F9B", "#605BE5"];
    const charts = {};
    const maps = new Map();
    const mapRenderRetryTimers = new Map();

    function configureCharts() {
      if (!window.Chart || configureCharts.done) return;
      Chart.defaults.font.family = "\"Inter Tight\", system-ui, -apple-system, \"Segoe UI\", sans-serif";
      Chart.defaults.color = "#52607f";
      Chart.defaults.borderColor = "rgba(42, 79, 218, 0.12)";
      Chart.defaults.plugins.tooltip.backgroundColor = "rgba(15, 23, 42, 0.9)";
      Chart.defaults.plugins.tooltip.titleColor = "#fff";
      Chart.defaults.plugins.tooltip.bodyColor = "#e2e8f0";
      configureCharts.done = true;
    }
    function destroyChart(id) {
      if (charts[id]) {
        charts[id].destroy();
        delete charts[id];
      }
    }

    function renderLineChart(canvasId, labels, values, title) {
      destroyChart(canvasId);
      if (!window.Chart) {
        console.warn("[UI] [chart] Chart.js not available; skipping", { canvasId });
        return;
      }
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;
      const labelsFmt = (labels || []).map((d) => fmtDateBr(d));

      charts[canvasId] = new Chart(ctx, {
        type: "line",
        data: { labels: labelsFmt, datasets: [{
          label: title,
          data: values,
          tension: 0.35,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: chartPalette[0],
          backgroundColor: "transparent",
          fill: false
        }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, title: { display: false } },
          scales: {
            x: { ticks: { maxTicksLimit: 8 }, grid: { display: false } },
            y: { grid: { color: "rgba(11, 31, 51, 0.08)" }, ticks: { maxTicksLimit: 5 } }
          }
        }
      });
    }

    function renderBarChart(canvasId, pairs, title, options = {}) {
      destroyChart(canvasId);
      if (!window.Chart) {
        console.warn("[UI] [chart] Chart.js not available; skipping", { canvasId });
        return;
      }
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;

      const labels = pairs.map(([k]) => k);
      const values = pairs.map(([,v]) => v);
      const useTopBarLabels = Boolean(options?.topBarLabels);
      const topBarLabelRotationDeg = Number(options?.topBarLabelRotationDeg ?? -40);
      const topBarLabelOffset = Number(options?.topBarLabelOffset ?? 10);
      const topBarLabelFontSize = Number(options?.topBarLabelFontSize ?? 10);
      const topBarLabelColor = String(options?.topBarLabelColor || "#334155");

      charts[canvasId] = new Chart(ctx, {
        type: "bar",
        data: { labels, datasets: [{
          label: title,
          data: values,
          backgroundColor: values.map((_, i)=>chartPalette[i % chartPalette.length]),
          borderRadius: 8,
          maxBarThickness: 26
        }] },
        plugins: useTopBarLabels ? [{
          id: `top-bar-labels-${canvasId}`,
          afterDatasetsDraw(chart) {
            const meta = chart.getDatasetMeta(0);
            if (!meta?.data?.length) return;
            const c = chart.ctx;
            const rotation = (topBarLabelRotationDeg * Math.PI) / 180;
            c.save();
            c.fillStyle = topBarLabelColor;
            c.font = `600 ${topBarLabelFontSize}px ${Chart.defaults.font.family}`;
            c.textAlign = "center";
            c.textBaseline = "bottom";
            meta.data.forEach((bar, index) => {
              const rawLabel = chart?.data?.labels?.[index];
              if (rawLabel == null) return;
              const x = Number(bar?.x);
              const yBase = Number(bar?.y);
              if (!Number.isFinite(x) || !Number.isFinite(yBase)) return;
              const y = Math.max(6, yBase - topBarLabelOffset);
              c.save();
              c.translate(x, y);
              c.rotate(rotation);
              c.fillText(String(rawLabel), 0, 0);
              c.restore();
            });
            c.restore();
          }
        }] : [],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: useTopBarLabels ? { padding: { top: 68 } } : undefined,
          plugins: { legend: { display: false } },
          scales: {
            x: {
              ticks: useTopBarLabels
                ? { display: false }
                : { autoSkip: false, maxRotation: 0, minRotation: 0 },
              grid: { display: false }
            },
            y: { grid: { color: "rgba(11, 31, 51, 0.08)" } }
          }
        }
      });
    }

    function renderDoughnut(canvasId, pairs, title, options = {}) {
      destroyChart(canvasId);
      if (!window.Chart) {
        console.warn("[UI] [chart] Chart.js not available; skipping", { canvasId });
        return;
      }
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;
      const percentMode = Boolean(options?.percentMode);
      const formatValue = (valueRaw) => {
        const value = Number(valueRaw || 0);
        if (percentMode) return `${fmtTrunc1(value)}%`;
        return fmtInt(value);
      };

      charts[canvasId] = new Chart(ctx, {
        type: "doughnut",
        data: {
          labels: pairs.map(([k]) => k),
          datasets: [{
            label: title,
            data: pairs.map(([,v]) => v),
            backgroundColor: pairs.map((_, i)=>chartPalette[i % chartPalette.length]),
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: "right", labels: { boxWidth: 10, usePointStyle: true } },
            tooltip: {
              callbacks: {
                label: (ctxTip) => {
                  const label = String(ctxTip?.label || "");
                  const value = ctxTip?.raw;
                  return `${label}: ${formatValue(value)}`;
                }
              }
            }
          },
          cutout: "65%"
        }
      });
    }

    function renderUfPills(pairs) {
      const box = document.getElementById("ufPills");
      if (!box) return;
      const selected = state.filters.uf || "Todos";
      const selectedCode = resolveUfCode(selected);
      const countByUf = new Map();
      const valueByCode = new Map(state.ufPillsValueByCode instanceof Map ? state.ufPillsValueByCode : []);
      for (const [ufRaw, countRaw] of (Array.isArray(pairs) ? pairs : [])) {
        const code = resolveUfCode(ufRaw);
        if (!code || !isValidUfValue(code)) continue;
        const prev = Number(countByUf.get(code) || 0);
        const next = Number(countRaw || 0);
        countByUf.set(code, prev + (Number.isFinite(next) ? next : 0));
        if (!valueByCode.has(code) && isValidUfValue(ufRaw)) {
          valueByCode.set(code, String(ufRaw).trim());
        }
      }
      const snapshotCounts = state.ufPillsCountsByCode instanceof Map ? state.ufPillsCountsByCode : new Map();
      const countsSource = snapshotCounts.size ? snapshotCounts : countByUf;
      const allUfCodes = Object.keys(UF_CENTROIDS);
      const items = allUfCodes
        .map((code) => [code, Number(countsSource.get(code) || 0)])
        .sort((a, b) => {
          const countDiff = Number(b[1] || 0) - Number(a[1] || 0);
          if (countDiff !== 0) return countDiff;
          return String(a[0]).localeCompare(String(b[0]), "pt-BR");
        });
      box.innerHTML = "";
      for (const [code, count] of items) {
        const btn = document.createElement("button");
        btn.className = "uf-pill" + (selectedCode && selectedCode === code ? " active" : "");
        btn.title = code;
        btn.innerHTML = `<span>${ufSigla(code)}</span><span class="text-slate-500">${fmtInt(count)}</span>`;
        btn.addEventListener("click", () => {
          const filterUfValue = valueByCode.get(code) || UF_CODE_TO_NAME[code] || code;
          applyFilters({ uf: filterUfValue }, { immediate: true, reason: "uf-pill" });
        });
        box.appendChild(btn);
      }
    }

    function updateUfPillsSnapshot(payload) {
      const ufFiltered = Boolean(sanitizeFilterValue(state.filters.uf));
      const counts = new Map();
      const values = new Map(state.ufPillsValueByCode instanceof Map ? state.ufPillsValueByCode : []);

      const byUf = Array.isArray(payload?.by_uf) ? payload.by_uf : [];
      if (byUf.length) {
        for (const row of byUf) {
          const rawUf = String(row?.uf || "").trim();
          const code = resolveUfCode(rawUf);
          if (!code) continue;
          const count = Number(row?.atendimentos ?? row?.inscritos ?? row?.ativos ?? 0);
          counts.set(code, Number.isFinite(count) ? count : 0);
          if (!values.has(code) && isValidUfValue(rawUf)) values.set(code, rawUf);
        }
      } else if (Array.isArray(payload?.events) && payload.events.length) {
        const pairs = topByKey(payload.events, "uf", (e)=>e.type==="atendimento" && isValidUfValue(e.uf), 27);
        for (const [rawUf, countRaw] of pairs) {
          const code = resolveUfCode(rawUf);
          if (!code) continue;
          const count = Number(countRaw || 0);
          counts.set(code, Number.isFinite(count) ? count : 0);
          if (!values.has(code) && isValidUfValue(rawUf)) values.set(code, String(rawUf).trim());
        }
      }

      const metaUfs = Array.isArray(payload?.meta?.available_ufs) ? payload.meta.available_ufs : [];
      for (const rawUf of metaUfs) {
        const code = resolveUfCode(rawUf);
        if (!code) continue;
        if (!values.has(code) && isValidUfValue(rawUf)) values.set(code, String(rawUf).trim());
      }

      if ((!ufFiltered || !state.ufPillsCountsByCode.size) && counts.size) {
        state.ufPillsCountsByCode = counts;
      }
      state.ufPillsValueByCode = values;
    }

    const BRAZIL_VIEW_BOUNDS = [[-34.9, -74.6], [5.5, -32.8]];
    const BRAZIL_UF_GEOJSON_URL = "https://cdn.jsdelivr.net/gh/codeforamerica/click_that_hood@master/public/data/brazil-states.geojson";
    const CEP_GEO_DICTIONARY_URL = "./data/geo_ceps_dictionary.json";
    const MAP_MAX_POINTS = 7000;
    const MAP_MIN_RENDER_SIZE = 24;
    let ufGeoJsonPromise = null;
    let cepGeoDictionaryPromise = null;
    const cepGeoDictionary = new Map();

    function mapHostSize(host) {
      if (!host) return { width: 0, height: 0 };
      const rect = host.getBoundingClientRect?.() || { width: 0, height: 0 };
      return {
        width: Math.floor(Math.max(Number(host.clientWidth || 0), Number(rect.width || 0))),
        height: Math.floor(Math.max(Number(host.clientHeight || 0), Number(rect.height || 0))),
      };
    }

    function isRenderableMapHost(host) {
      const size = mapHostSize(host);
      return size.width >= MAP_MIN_RENDER_SIZE && size.height >= MAP_MIN_RENDER_SIZE;
    }

    function clearMapRenderRetry(containerId) {
      const timer = mapRenderRetryTimers.get(containerId);
      if (timer) clearTimeout(timer);
      mapRenderRetryTimers.delete(containerId);
    }

    function scheduleMapRenderRetry(containerId, events, delayMs = 180) {
      if (mapRenderRetryTimers.has(containerId)) return;
      const timer = setTimeout(() => {
        mapRenderRetryTimers.delete(containerId);
        renderMapPoints(containerId, events);
      }, delayMs);
      mapRenderRetryTimers.set(containerId, timer);
    }

    function fetchJsonWithTimeout(url, timeoutMs = 15000) {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), timeoutMs);
      return fetch(url, { signal: controller.signal, cache: "force-cache" })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .finally(() => clearTimeout(timeout));
    }

    function loadUfGeoJson() {
      if (ufGeoJsonPromise) return ufGeoJsonPromise;
      console.debug("[UI] [map] geojson:load:start", { url: BRAZIL_UF_GEOJSON_URL });
      ufGeoJsonPromise = fetchJsonWithTimeout(BRAZIL_UF_GEOJSON_URL, 15000)
        .then((geojson) => {
          const features = Array.isArray(geojson?.features) ? geojson.features.length : 0;
          if (!features) throw new Error("GeoJSON de UFs invalido.");
          console.info("[UI] [map] geojson:load:ok", { features });
          return geojson;
        })
        .catch((err) => {
          console.warn("[UI] [map] geojson:load:fail", { err: String(err) });
          ufGeoJsonPromise = null;
          return null;
        });
      return ufGeoJsonPromise;
    }

    function indexCepGeoDictionary(rows) {
      let count = 0;
      for (const row of Array.isArray(rows) ? rows : []) {
        const cep = normalizeCep(row?.cep);
        if (!cep) continue;
        const lat = toFiniteNumberOrNaN(row?.lat);
        const lng = toFiniteNumberOrNaN(row?.lng);
        const cidade = isValidCityValue(row?.cidade) ? String(row.cidade).trim() : "";
        const ufCode = resolveUfCode(row?.uf);
        const uf = ufCode || (isValidUfValue(row?.uf) ? String(row.uf).trim() : "");
        cepGeoDictionary.set(cep, {
          cep,
          lat: Number.isFinite(lat) ? lat : null,
          lng: Number.isFinite(lng) ? lng : null,
          cidade: cidade || null,
          uf: uf || null,
        });
        count += 1;
      }
      return count;
    }

    function loadCepGeoDictionary() {
      if (cepGeoDictionaryPromise) return cepGeoDictionaryPromise;
      const inlineRows = Array.isArray(window.__GEO_CEPS_DICTIONARY) ? window.__GEO_CEPS_DICTIONARY : null;
      if (inlineRows && inlineRows.length) {
        cepGeoDictionaryPromise = Promise.resolve().then(() => {
          const total = indexCepGeoDictionary(inlineRows);
          console.info("[UI] [map] cep-dict:inline:ok", { rows: total });
          return total;
        });
        return cepGeoDictionaryPromise;
      }
      console.debug("[UI] [map] cep-dict:load:start", { url: CEP_GEO_DICTIONARY_URL });
      cepGeoDictionaryPromise = fetchJsonWithTimeout(CEP_GEO_DICTIONARY_URL, 12000)
        .then((rows) => {
          const total = indexCepGeoDictionary(rows);
          console.info("[UI] [map] cep-dict:load:ok", { rows: total });
          return total;
        })
        .catch((err) => {
          console.warn("[UI] [map] cep-dict:load:fail", {
            err: String(err),
            protocol: String(location.protocol || ""),
            hint: "Use http://localhost (nao file://) ou mantenha data/geo_ceps_dictionary.js carregado.",
          });
          return 0;
        });
      return cepGeoDictionaryPromise;
    }

    function hydrateByCepRows(rows) {
      if (!Array.isArray(rows) || !rows.length) return [];
      return rows.map((row) => {
        const cep = normalizeCep(row?.cep);
        if (!cep) return row;
        const dict = cepGeoDictionary.get(cep);
        if (!dict) return row;

        const cityRaw = String(row?.cidade || "").trim();
        const ufRaw = String(row?.uf || "").trim();
        const ufFromRow = resolveUfCode(ufRaw);
        const ufFromDict = resolveUfCode(dict.uf);
        const nextUf = ufFromRow ? ufRaw : (ufFromDict ? dict.uf : (ufRaw || dict.uf || "N/A"));
        const nextCity = isValidCityValue(cityRaw) ? cityRaw : (dict.cidade || cityRaw || "N/A");

        return {
          ...row,
          cidade: nextCity,
          uf: nextUf,
        };
      });
    }

    function ufStyle(active = false) {
      return {
        color: active ? "#00d95d" : "#94a3b8",
        weight: active ? 2.4 : 1.35,
        fillColor: active ? "#00d95d" : "#2a4fda",
        fillOpacity: active ? 0.08 : 0,
      };
    }

    function featureUfCode(feature) {
      const props = feature?.properties || {};
      return (
        resolveUfCode(props.sigla) ||
        resolveUfCode(props.uf) ||
        resolveUfCode(props.UF) ||
        resolveUfCode(props.name) ||
        resolveUfCode(props.nome) ||
        ""
      );
    }

    function pointInRing(lng, lat, ring) {
      if (!Array.isArray(ring) || ring.length < 3) return false;
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const pi = ring[i] || [];
        const pj = ring[j] || [];
        const xi = Number(pi[0]);
        const yi = Number(pi[1]);
        const xj = Number(pj[0]);
        const yj = Number(pj[1]);
        if (!Number.isFinite(xi) || !Number.isFinite(yi) || !Number.isFinite(xj) || !Number.isFinite(yj)) continue;
        const intersects = ((yi > lat) !== (yj > lat)) &&
          (lng < ((xj - xi) * (lat - yi)) / ((yj - yi) || 1e-12) + xi);
        if (intersects) inside = !inside;
      }
      return inside;
    }

    function pointInPolygonCoords(lng, lat, polygonCoords) {
      if (!Array.isArray(polygonCoords) || !polygonCoords.length) return false;
      const [outer, ...holes] = polygonCoords;
      if (!pointInRing(lng, lat, outer)) return false;
      for (const hole of holes) {
        if (pointInRing(lng, lat, hole)) return false;
      }
      return true;
    }

    function pointInGeometry(lng, lat, geometry) {
      if (!geometry || typeof geometry !== "object") return false;
      if (geometry.type === "Polygon") {
        return pointInPolygonCoords(lng, lat, geometry.coordinates);
      }
      if (geometry.type === "MultiPolygon") {
        const polys = Array.isArray(geometry.coordinates) ? geometry.coordinates : [];
        return polys.some((poly) => pointInPolygonCoords(lng, lat, poly));
      }
      return false;
    }

    function pointInsideSelectedUfPolygon(ctx, selectedUfCode, lat, lng) {
      if (!ctx || !selectedUfCode) return true;
      const geoms = ctx.ufGeometriesByCode?.get(selectedUfCode);
      if (!Array.isArray(geoms) || !geoms.length) return true;
      const latNum = Number(lat);
      const lngNum = Number(lng);
      if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) return false;
      return geoms.some((geom) => pointInGeometry(lngNum, latNum, geom));
    }

    function attachHeatLegend(map) {
      if (!window.L) return null;
      const legend = L.control({ position: "bottomleft" });
      legend.onAdd = () => {
        const div = L.DomUtil.create("div", "leaflet-heat-legend");
        div.innerHTML = `
          <div class="bar"></div>
          <div class="labels">
            <span data-role="low">Baixo: --</span>
            <span data-role="high">Alto: --</span>
          </div>
          <div class="meta">Intensidade por inscritos</div>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legend.addTo(map);
      return legend;
    }

    function fmtHeatLegendValue(v) {
      const n = Math.max(0, Math.round(Number(v || 0)));
      return `${fmtInt(n)} inscrito${n === 1 ? "" : "s"}`;
    }

    function updateHeatLegend(ctx, heatData) {
      const container = ctx?.legendControl?.getContainer?.() || null;
      if (!container) return;
      const lowEl = container.querySelector('[data-role="low"]');
      const highEl = container.querySelector('[data-role="high"]');
      if (!lowEl || !highEl) return;

      const values = (Array.isArray(heatData) ? heatData : [])
        .map((cell) => Number(cell?.inscritos || 0))
        .filter((n) => Number.isFinite(n) && n > 0);

      if (!values.length) {
        lowEl.textContent = "Baixo: --";
        highEl.textContent = "Alto: --";
        return;
      }

      const low = Math.min(...values);
      const high = Math.max(...values);
      lowEl.textContent = `Baixo: ${fmtHeatLegendValue(low)}`;
      highEl.textContent = `Alto: ${fmtHeatLegendValue(high)}`;
    }

    function heatColorForIntensity(v) {
      const x = clamp(Number(v || 0), 0, 1);
      if (x >= 0.85) return "#ff3b30";
      if (x >= 0.65) return "#ffc940";
      if (x >= 0.45) return "#9fff2f";
      if (x >= 0.3) return "#00d95d";
      if (x >= 0.15) return "#00f9ff";
      return "#4d7bff";
    }

    function heatTooltipHtml(cell) {
      const noUfSelected = !resolveUfCode(state?.filters?.uf);
      const isUfAggregate = String(cell?.focusKey || "").endsWith("|uf");
      const ufCode = resolveUfCode(cell?.uf);
      const title = (noUfSelected || isUfAggregate)
        ? `UF ${ufCode || ufSigla(cell?.uf) || String(cell?.uf || "").trim() || "N/A"}`
        : (mapCityFocusLabelFromRow({ city: cell?.city, uf: cell?.uf }) || "Local");
      const inscritos = Number(cell?.inscritos || 0);
      const atendimentos = Number(cell?.atendimentos || 0);
      return `
        <div class="heat-tip-title">${escapeHtml(title)}</div>
        <div>Inscritos: <strong>${escapeHtml(fmtInt(inscritos))}</strong></div>
        <div>Atendimentos: <strong>${escapeHtml(fmtInt(atendimentos))}</strong></div>
      `;
    }

    function renderHeatFallback(ctx, heatData) {
      if (!ctx?.fallbackHeatLayer || !window.L) return 0;
      ctx.fallbackHeatLayer.clearLayers();
      const renderer = ctx?.heatRenderer || null;
      let drawn = 0;
      for (const cell of heatData || []) {
        const lat = Number(cell?.lat);
        const lng = Number(cell?.lng);
        const intensity = clamp(Number(cell?.intensity || 0), 0.1, 1);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

        const baseOptions = {
          pane: "heatPane",
          interactive: false,
        };
        if (renderer) baseOptions.renderer = renderer;

        const halo = L.circleMarker([lat, lng], {
          ...baseOptions,
          radius: 14 + (intensity * 24),
          stroke: false,
          fillColor: heatColorForIntensity(intensity),
          fillOpacity: 0.16 + (intensity * 0.34),
        });
        ctx.fallbackHeatLayer.addLayer(halo);

        const core = L.circleMarker([lat, lng], {
          ...baseOptions,
          radius: 5 + (intensity * 12),
          stroke: true,
          weight: 1,
          color: "rgba(255,255,255,0.45)",
          fillColor: heatColorForIntensity(intensity),
          fillOpacity: 0.42 + (intensity * 0.44),
          interactive: true,
          bubblingMouseEvents: false,
        });
        core.bindTooltip(heatTooltipHtml(cell), {
          sticky: true,
          direction: "bottom",
          offset: L.point(0, 12),
          opacity: 0.98,
          className: "heat-tooltip",
        });
        ctx.fallbackHeatLayer.addLayer(core);
        drawn++;
      }
      if (typeof ctx.fallbackHeatLayer.bringToFront === "function") {
        ctx.fallbackHeatLayer.bringToFront();
      }
      return drawn;
    }

    function buildHeatBounds(heatData) {
      if (!window.L || !Array.isArray(heatData) || !heatData.length) return null;
      const points = [];
      for (const cell of heatData) {
        const lat = Number(cell?.lat);
        const lng = Number(cell?.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
        points.push([lat, lng]);
      }
      if (!points.length) return null;
      const bounds = L.latLngBounds(points);
      return bounds && bounds.isValid() ? bounds : null;
    }

    function ensureUfLayer(ctx) {
      if (!ctx || !ctx.map || !window.L) return Promise.resolve(null);
      if (ctx.ufLayerPromise) return ctx.ufLayerPromise;
      ctx.ufLayerPromise = loadUfGeoJson().then((geojson) => {
        if (!geojson || !Array.isArray(geojson.features)) {
          ctx.ufLayerPromise = null;
          return null;
        }
        const boundsByCode = new Map();
        const geomsByCode = new Map();
        ctx.ufLayer = L.geoJSON(geojson, {
          pane: "ufPane",
          style: () => ufStyle(false),
          onEachFeature: (feature, layer) => {
            const code = featureUfCode(feature);
            if (!code) return;
            layer.__ufCode = code;
            const geom = feature?.geometry;
            if (geom && (geom.type === "Polygon" || geom.type === "MultiPolygon")) {
              if (!geomsByCode.has(code)) geomsByCode.set(code, []);
              geomsByCode.get(code).push(geom);
            }
            const bounds = layer.getBounds();
            if (!bounds || !bounds.isValid()) return;
            if (!boundsByCode.has(code)) boundsByCode.set(code, bounds);
            else boundsByCode.get(code).extend(bounds);
          },
        }).addTo(ctx.map);
        ctx.ufBoundsByCode = boundsByCode;
        ctx.ufGeometriesByCode = geomsByCode;
        console.info("[UI] [map] uf layer attached", { containerId: ctx.containerId, ufs: boundsByCode.size });
        return ctx.ufLayer;
      });
      return ctx.ufLayerPromise;
    }

    function styleUfLayer(ctx, selectedUfCode) {
      if (!ctx?.ufLayer) return;
      ctx.ufLayer.eachLayer((layer) => {
        const active = !!selectedUfCode && layer.__ufCode === selectedUfCode;
        layer.setStyle(ufStyle(active));
      });
    }

    function fitMapViewport(ctx, selectedUfCode, force = false) {
      if (!ctx?.map) return;
      const key = selectedUfCode || "ALL";
      if (!force && ctx.lastViewportKey === key) return;

      if (selectedUfCode) {
        const bounds = ctx.ufBoundsByCode?.get(selectedUfCode);
        if (bounds && bounds.isValid()) {
          ctx.map.fitBounds(bounds.pad(0.14), { maxZoom: 8, animate: false });
        } else {
          const geo = resolveUfGeo(selectedUfCode);
          if (geo) {
            ctx.map.setView([geo.lat, geo.lng], 6, { animate: false });
          } else {
            ctx.map.fitBounds(BRAZIL_VIEW_BOUNDS, { animate: false });
          }
        }
      } else {
        ctx.map.fitBounds(BRAZIL_VIEW_BOUNDS, { animate: false });
      }
      ctx.lastViewportKey = key;
    }

    function ensureMap(containerId) {
      const host = document.getElementById(containerId);
      if (!host) return null;
      if (maps.has(containerId)) return maps.get(containerId);
      const size = mapHostSize(host);
      if (size.width < MAP_MIN_RENDER_SIZE || size.height < MAP_MIN_RENDER_SIZE) {
        return null;
      }

      host.innerHTML = "";
      host.classList.add("leaflet-map-host");

      if (!window.L) {
        host.innerHTML = `<div class="map-empty-state">Leaflet indisponivel para renderizar o mapa.</div>`;
        console.warn("[UI] [map] Leaflet indisponivel", { containerId });
        return null;
      }

      const map = L.map(host, {
        zoomControl: true,
        attributionControl: true,
        preferCanvas: false,
        minZoom: 3,
        maxZoom: 11,
        worldCopyJump: false,
        scrollWheelZoom: true,
      });

      if (!map.getPane("ufPane")) {
        const ufPane = map.createPane("ufPane");
        ufPane.style.zIndex = "450";
        ufPane.style.pointerEvents = "none";
      }
      if (!map.getPane("heatShadowPane")) {
        const heatShadowPane = map.createPane("heatShadowPane");
        heatShadowPane.style.zIndex = "640";
        heatShadowPane.style.pointerEvents = "none";
      }
      if (!map.getPane("heatPane")) {
        const heatPane = map.createPane("heatPane");
        heatPane.style.zIndex = "680";
        heatPane.style.pointerEvents = "auto";
      }
      const heatRenderer = L.svg({ pane: "heatPane" });
      heatRenderer.addTo(map);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 12,
        attribution: "&copy; OpenStreetMap",
        crossOrigin: "anonymous",
      }).addTo(map);

      const heatLayer = window.L?.heatLayer
        ? L.heatLayer([], {
            radius: 30,
            blur: 24,
            maxZoom: 9,
            minOpacity: 0.42,
            pane: "heatShadowPane",
            gradient: {
              0.00: "#12309b",
              0.20: "#2a4fda",
              0.40: "#00f9ff",
              0.62: "#00d95d",
              0.80: "#ffc940",
              1.00: "#ff3b30",
            },
          }).addTo(map)
        : null;

      if (!heatLayer) {
        console.warn("[UI] [map] leaflet.heat indisponivel", { containerId });
      }

      const emptyState = document.createElement("div");
      emptyState.className = "map-empty-state hidden";
      emptyState.textContent = "Sem dados geograficos no recorte atual.";
      emptyState.style.display = "none";
      host.appendChild(emptyState);

      const ctx = {
        containerId,
        host,
        map,
        heatLayer,
        fallbackHeatLayer: L.layerGroup().addTo(map),
        heatRenderer,
        legendControl: null,
        emptyState,
        ufLayer: null,
        ufLayerPromise: null,
        ufBoundsByCode: new Map(),
        ufGeometriesByCode: new Map(),
        lastViewportKey: "",
        lastEvents: [],
      };

      ctx.legendControl = attachHeatLegend(map);
      map.fitBounds(BRAZIL_VIEW_BOUNDS, { animate: false });

      maps.set(containerId, ctx);
      console.info("[UI] [map] Leaflet initialized", { containerId });
      return ctx;
    }

    function buildGeoPointsFromByUf(byUfRows) {
      if (!Array.isArray(byUfRows)) return [];
      const points = [];
      for (const row of byUfRows) {
        const geo = resolveUfGeo(row?.uf);
        if (!geo) continue;
        const atendimentos = Number(row?.atendimentos || 0);
        const inscritos = Number(row?.inscritos || 0);
        const ativos = Number(row?.ativos || 0);
        const weight = Math.max(inscritos, 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;
        points.push({
          uf: String(row?.uf || geo.uf || ""),
          city: geo.city,
          lat: geo.lat,
          lng: geo.lng,
          weight,
          atendimentos,
          inscritos,
          ativos,
        });
      }
      return points;
    }

    function buildGeoPointsFromByCidade(byCityRows) {
      if (!Array.isArray(byCityRows)) return [];
      const points = [];
      for (const row of byCityRows) {
        const ufRaw = String(row?.uf || "").trim();
        const city = resolveCityLabelFromRow(row);
        if (!city) continue;
        const geo = resolveUfGeo(ufRaw);
        if (!geo) continue;

        const atendimentos = Number(row?.atendimentos || 0);
        const inscritos = Number(row?.inscritos || 0);
        const ativos = Number(row?.ativos || 0);
        const weight = Math.max(inscritos, 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;

        const seed = `${geo.uf}|${city}`;
        const latOffset = (((hashString(seed + "|lat") % 1000) / 1000) - 0.5) * 0.12;
        const lngOffset = (((hashString(seed + "|lng") % 1000) / 1000) - 0.5) * 0.14;

        points.push({
          uf: geo.uf,
          city,
          lat: geo.lat + latOffset,
          lng: geo.lng + lngOffset,
          weight,
          atendimentos,
          inscritos,
          ativos,
        });
      }
      return points;
    }

    function buildGeoPointsFromByCep(byCepRows) {
      if (!Array.isArray(byCepRows)) return [];
      const grouped = new Map();
      for (const row of byCepRows) {
        const cep = normalizeCep(row?.cep);
        if (!cep) continue;
        const dict = cepGeoDictionary.get(cep);
        const ufCode = resolveUfCode(row?.uf) || resolveUfCode(dict?.uf);
        if (!ufCode) continue;
        const geo = resolveUfGeo(ufCode);
        if (!geo) continue;

        const city = resolveCityLabelFromRow({ ...row, cep });
        if (!city) continue;

        let lat = toFiniteNumberOrNaN(row?.lat);
        let lng = toFiniteNumberOrNaN(row?.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
          lat = toFiniteNumberOrNaN(dict?.lat);
          lng = toFiniteNumberOrNaN(dict?.lng);
        }
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

        const atendimentos = Number(row?.atendimentos || 0);
        const inscritos = Number(row?.inscritos || 0);
        const ativos = Number(row?.ativos || 0);
        const weight = Math.max(inscritos, 0);
        if (!Number.isFinite(weight) || weight <= 0) continue;

        const key = `${ufCode}|${normalizeTextKey(city)}`;
        const prev = grouped.get(key);
        if (prev) {
          prev.weight += weight;
          prev.inscritos += inscritos;
          prev.atendimentos += atendimentos;
          prev.ativos += ativos;
          const cw = Math.max(1, weight);
          prev.latWeightSum += lat * cw;
          prev.lngWeightSum += lng * cw;
          prev.coordWeight += cw;
        } else {
          const cw = Math.max(1, weight);
          grouped.set(key, {
            uf: ufCode,
            city,
            weight,
            atendimentos,
            inscritos,
            ativos,
            latWeightSum: lat * cw,
            lngWeightSum: lng * cw,
            coordWeight: cw,
          });
        }
      }
      return Array.from(grouped.values()).map((row) => ({
        uf: row.uf,
        city: row.city,
        lat: row.coordWeight > 0 ? row.latWeightSum / row.coordWeight : NaN,
        lng: row.coordWeight > 0 ? row.lngWeightSum / row.coordWeight : NaN,
        weight: row.weight,
        atendimentos: row.atendimentos,
        inscritos: row.inscritos,
        ativos: row.ativos,
      })).filter((row) => Number.isFinite(row.lat) && Number.isFinite(row.lng));
    }

    function hasGeoPointForUf(points, ufValue) {
      const code = resolveUfCode(ufValue);
      if (!code || !Array.isArray(points) || !points.length) return false;
      return points.some((p) => resolveUfCode(p?.uf) === code);
    }

    function normalizeMapPoint(row) {
      let lat = toFiniteNumberOrNaN(row?.lat);
      let lng = toFiniteNumberOrNaN(row?.lng);
      const uf = resolveUfCode(row?.uf);

      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        const geo = resolveUfGeo(uf || row?.uf);
        if (geo) {
          lat = Number(geo.lat);
          lng = Number(geo.lng);
        }
      }

      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
      let inscritos = toFiniteNumberOrNaN(row?.inscritos);
      let atendimentos = toFiniteNumberOrNaN(row?.atendimentos);
      const ativos = Number(row?.ativos || 0);

      const typeNorm = normalizeTextKey(row?.type);
      if (!Number.isFinite(inscritos)) {
        if (typeNorm.includes("inscricao")) inscritos = 1;
        else inscritos = 0;
      }
      if (!Number.isFinite(atendimentos)) {
        atendimentos = typeNorm.includes("atendimento") ? 1 : 0;
      }

      const weight = Math.max(Number(inscritos || 0), 0);
      if (!Number.isFinite(weight) || weight <= 0) return null;

      const city = resolveCityLabelFromRow(row);
      if (!city) return null;
      const focusKey = mapCityFocusKeyFromRow({ uf, city });
      return { lat, lng, uf, weight, city, inscritos: Number(inscritos || 0), atendimentos: Number(atendimentos || 0), ativos, focusKey };
    }

    function buildLeafletHeatCells(events, selectedUfCode, focusedCityKey = "", options = {}) {
      if (!Array.isArray(events) || !events.length) return [];
      const buckets = new Map();
      const focusKey = String(focusedCityKey || "").trim();
      const pointInSelectedUf = typeof options.pointInSelectedUf === "function" ? options.pointInSelectedUf : null;

      for (const row of events.slice(0, 120000)) {
        const point = normalizeMapPoint(row);
        if (!point) continue;
        if (selectedUfCode && point.uf && point.uf !== selectedUfCode) continue;
        if (selectedUfCode && pointInSelectedUf && !pointInSelectedUf(point.lat, point.lng)) continue;
        if (focusKey && !matchesMapCityFocus(point.focusKey, focusKey)) continue;
        const lat = Number(point.lat);
        const lng = Number(point.lng);
        const key = point.focusKey || `${point.uf || ""}|city:${normalizeTextKey(point.city || "")}`;
        const prev = buckets.get(key);
        if (prev) {
          prev.weight += point.weight;
          prev.inscritos += Number(point.inscritos || 0);
          prev.atendimentos += Number(point.atendimentos || 0);
          prev.ativos += Number(point.ativos || 0);
          prev.latWeightSum += lat * Math.max(1, Number(point.weight || 0));
          prev.lngWeightSum += lng * Math.max(1, Number(point.weight || 0));
          prev.weightSum += Math.max(1, Number(point.weight || 0));
          if (!prev.city && point.city) prev.city = point.city;
          if (!prev.uf && point.uf) prev.uf = point.uf;
        } else {
          const w = Math.max(1, Number(point.weight || 0));
          buckets.set(key, {
            lat,
            lng,
            weight: point.weight,
            city: point.city || "",
            uf: point.uf || "",
            inscritos: Number(point.inscritos || 0),
            atendimentos: Number(point.atendimentos || 0),
            ativos: Number(point.ativos || 0),
            focusKey: point.focusKey || "",
            latWeightSum: lat * w,
            lngWeightSum: lng * w,
            weightSum: w,
          });
        }
      }

      const cells = Array.from(buckets.values())
        .sort((a, b) => b.weight - a.weight)
        .slice(0, MAP_MAX_POINTS);

      if (!cells.length) return [];
      const maxWeight = Math.max(1, ...cells.map((c) => Number(c.weight || 0)));
      return cells.map((c) => ({
        ...c,
        lat: Number(c.weightSum) > 0 ? (Number(c.latWeightSum || 0) / Number(c.weightSum || 1)) : Number(c.lat),
        lng: Number(c.weightSum) > 0 ? (Number(c.lngWeightSum || 0) / Number(c.weightSum || 1)) : Number(c.lng),
        intensity: clamp(Number(c.weight || 0) / maxWeight, 0.08, 1),
      }));
    }

    function buildUfHeatCells(events) {
      if (!Array.isArray(events) || !events.length) return [];
      const byUf = new Map();

      for (const row of events.slice(0, 120000)) {
        const code = resolveUfCode(row?.uf);
        if (!code) continue;

        let inscritos = toFiniteNumberOrNaN(row?.inscritos);
        if (!Number.isFinite(inscritos)) inscritos = toFiniteNumberOrNaN(row?.weight);
        if (!Number.isFinite(inscritos)) {
          inscritos = normalizeTextKey(row?.type).includes("INSCRICAO") ? 1 : 0;
        }
        if (!Number.isFinite(inscritos) || inscritos <= 0) continue;

        let atendimentos = toFiniteNumberOrNaN(row?.atendimentos);
        if (!Number.isFinite(atendimentos)) {
          atendimentos = normalizeTextKey(row?.type).includes("ATENDIMENTO") ? 1 : 0;
        }
        if (!Number.isFinite(atendimentos)) atendimentos = 0;

        const prev = byUf.get(code) || { inscritos: 0, atendimentos: 0 };
        prev.inscritos += inscritos;
        prev.atendimentos += atendimentos;
        byUf.set(code, prev);
      }

      if (!byUf.size) return [];
      const items = Array.from(byUf.entries());
      const maxW = Math.max(1, ...items.map(([, agg]) => Number(agg?.inscritos || 0)));

      return items
        .map(([code, agg]) => {
          const geo = resolveUfGeo(code);
          if (!geo) return null;
          const inscritos = Number(agg?.inscritos || 0);
          const atendimentos = Number(agg?.atendimentos || 0);
          if (!Number.isFinite(inscritos) || inscritos <= 0) return null;
          return {
            lat: Number(geo.lat),
            lng: Number(geo.lng),
            intensity: clamp(inscritos / maxW, 0.35, 1),
            weight: inscritos,
            city: "",
            uf: code,
            cep: "",
            inscritos,
            atendimentos,
            ativos: 0,
            focusKey: mapCityFocusKeyFromRow({ uf: code }),
          };
        })
        .filter(Boolean);
    }

    function toggleMapEmptyState(ctx, show) {
      if (!ctx?.emptyState) return;
      ctx.emptyState.style.display = show ? "block" : "none";
      ctx.emptyState.classList.toggle("hidden", !show);
    }

    function syncTerritoryCitiesFromHeatData(heatData, selectedUfCode) {
      if (state.page !== "territory") return;
      const citiesEl = document.getElementById("terrCities");
      const coverageEl = document.getElementById("terrUfCoverage");
      if (!citiesEl) return;
      if (!selectedUfCode) {
        citiesEl.textContent = "—";
        return;
      }
      const cityCount = countDistinctCities(heatData);
      citiesEl.textContent = `${fmtInt(cityCount)} cidades`;
      if (coverageEl) {
        const totalCities = Number(UF_CITY_TOTALS[selectedUfCode] || 0);
        if (!totalCities) {
          coverageEl.textContent = "--";
        } else {
          const pct = cityCount / totalCities;
          coverageEl.textContent = `${fmtPct(pct)} (${fmtInt(cityCount)}/${fmtInt(totalCities)})`;
        }
      }
    }

    function renderMapPoints(containerId, events) {
      const host = document.getElementById(containerId);
      if (!host) return;
      let size = mapHostSize(host);
      if (size.width < MAP_MIN_RENDER_SIZE || size.height < MAP_MIN_RENDER_SIZE) {
        if (size.height < MAP_MIN_RENDER_SIZE && !host.style.minHeight) {
          host.style.minHeight = "220px";
        }
        size = mapHostSize(host);
      }
      if (size.width < MAP_MIN_RENDER_SIZE || size.height < MAP_MIN_RENDER_SIZE) {
        scheduleMapRenderRetry(containerId, events);
        console.debug("[UI] [map] defer render (container without size)", {
          containerId,
          width: size.width,
          height: size.height,
        });
        return;
      }
      clearMapRenderRetry(containerId);

      const ctx = ensureMap(containerId);
      if (!ctx) {
        scheduleMapRenderRetry(containerId, events);
        return;
      }
      ctx.lastEvents = Array.isArray(events) ? events : [];

      const selectedUfCode = resolveUfCode(state.filters.uf);
      const focusedCityKey = selectedUfCode && containerId === "mapTerritory"
        ? String(state.mapCityFocus?.key || "")
        : "";
      if (!selectedUfCode && state.mapCityFocus) state.mapCityFocus = null;

      let heatData = [];
      if (!selectedUfCode) {
        // Sem UF selecionada: somente calor agregado por UF.
        heatData = buildUfHeatCells(ctx.lastEvents);
      } else {
        const hasUfGeometry = Boolean(ctx.ufGeometriesByCode?.has(selectedUfCode));
        if (!hasUfGeometry && !ctx.ufLayer) {
          ensureUfLayer(ctx)
            .then(() => renderMapPoints(containerId, ctx.lastEvents))
            .catch((err) => {
              console.warn("[UI] [map] UF geometry preload failed", { containerId, err: String(err) });
            });
          if (ctx.heatLayer && typeof ctx.heatLayer.setLatLngs === "function") ctx.heatLayer.setLatLngs([]);
          if (ctx.fallbackHeatLayer && typeof ctx.fallbackHeatLayer.clearLayers === "function") ctx.fallbackHeatLayer.clearLayers();
          toggleMapEmptyState(ctx, true);
          updateHeatLegend(ctx, []);
          return;
        }

        const polygonFilter = hasUfGeometry
          ? ((lat, lng) => pointInsideSelectedUfPolygon(ctx, selectedUfCode, lat, lng))
          : null;

        heatData = buildLeafletHeatCells(ctx.lastEvents, selectedUfCode, focusedCityKey, {
          pointInSelectedUf: polygonFilter,
        });

        if (!heatData.length && focusedCityKey) {
          state.mapCityFocus = null;
          heatData = buildLeafletHeatCells(ctx.lastEvents, selectedUfCode, "", {
            pointInSelectedUf: polygonFilter,
          });
        }
      }
      toggleMapEmptyState(ctx, heatData.length === 0);
      updateHeatLegend(ctx, heatData);
      if (containerId === "mapTerritory") {
        syncTerritoryCitiesFromHeatData(heatData, selectedUfCode);
      }

      try {
        let fallbackDrawn = 0;
        const canRenderHeat = isRenderableMapHost(ctx.host || host);
        if (ctx.heatLayer && typeof ctx.heatLayer.setLatLngs === "function") {
          const heatTuples = heatData
            .map((cell) => [Number(cell?.lat), Number(cell?.lng), Number(cell?.intensity || 0)])
            .filter((v) => Number.isFinite(v[0]) && Number.isFinite(v[1]) && Number.isFinite(v[2]) && v[2] > 0);
          ctx.heatLayer.setLatLngs(canRenderHeat ? heatTuples : []);
        }
        if (canRenderHeat) {
          // Mantem camada vetorial de calor sempre ativa para nao depender
          // exclusivamente do comportamento do plugin leaflet.heat.
          fallbackDrawn = renderHeatFallback(ctx, heatData);
        } else if (ctx.fallbackHeatLayer && typeof ctx.fallbackHeatLayer.clearLayers === "function") {
          ctx.fallbackHeatLayer.clearLayers();
        }
        ctx.lastFallbackDrawn = fallbackDrawn;
      } catch (err) {
        console.warn("[UI] [map] heat layer update failed; using fallback", {
          containerId,
          err: String(err),
        });
        if (isRenderableMapHost(ctx.host || host)) {
          ctx.lastFallbackDrawn = renderHeatFallback(ctx, heatData);
        } else {
          ctx.lastFallbackDrawn = 0;
        }
      }

      try {
        if (isRenderableMapHost(ctx.host || host)) {
          ctx.map.invalidateSize({ pan: false, animate: false });
          styleUfLayer(ctx, selectedUfCode);
          fitMapViewport(ctx, selectedUfCode);
          if ((selectedUfCode || focusedCityKey) && heatData.length) {
            const heatBounds = buildHeatBounds(heatData);
            if (heatBounds) {
              ctx.map.fitBounds(heatBounds.pad(0.42), { maxZoom: 8, animate: false });
            }
          }
        }
      } catch (err) {
        console.warn("[UI] [map] viewport update failed", { containerId, err: String(err) });
      }

      const hadUfLayer = !!ctx.ufLayer;
      ensureUfLayer(ctx)
        .then(() => {
          if (!isRenderableMapHost(ctx.host || host)) return;
          styleUfLayer(ctx, selectedUfCode);
          fitMapViewport(ctx, selectedUfCode, !hadUfLayer);
          if (ctx?.heatLayer && typeof ctx.heatLayer.bringToFront === "function") {
            ctx.heatLayer.bringToFront();
          }
          if (ctx?.fallbackHeatLayer && typeof ctx.fallbackHeatLayer.bringToFront === "function") {
            ctx.fallbackHeatLayer.bringToFront();
          }
        })
        .catch((err) => {
          console.warn("[UI] [map] UF layer update failed", { containerId, err: String(err) });
        });

      console.info("[UI] [map] rendered", {
        containerId,
        heatPoints: heatData.length,
        fallbackPoints: Number(ctx.lastFallbackDrawn || 0),
        fallbackLayers: Number(ctx?.fallbackHeatLayer?.getLayers?.().length || 0),
        focusedCity: state.mapCityFocus?.label || "",
        selectedUf: selectedUfCode || "ALL",
      });
    }

    // =========================================================
    // Render (paginas)
    // =========================================================
    function setPage(page) {
      state.page = page;
      location.hash = page;
      render();
    }

    const PAGES = new Set(["overview", "territory", "engagement", "content"]);

    function currentHashPage() {
      const h = (location.hash || "").replace("#", "").trim();
      if (!h) return "overview";
      return PAGES.has(h) ? h : "overview";
    }

    function syncPresetButtons() {
      const btn30 = document.getElementById("btnPreset30");
      const btn90 = document.getElementById("btnPreset90");
      const btnAll = document.getElementById("btnPresetAll");
      if (!state.fullRange.from || !state.fullRange.to) return;

      let d30 = shiftDate(state.fullRange.to, -29);
      let d90 = shiftDate(state.fullRange.to, -89);
      if (d30 < state.fullRange.from) d30 = state.fullRange.from;
      if (d90 < state.fullRange.from) d90 = state.fullRange.from;

      const is30 = state.filters.dateFrom === d30 && state.filters.dateTo === state.fullRange.to;
      const is90 = state.filters.dateFrom === d90 && state.filters.dateTo === state.fullRange.to;
      const isAll = state.filters.dateFrom === state.fullRange.from && state.filters.dateTo === state.fullRange.to;

      if (btn30) btn30.classList.toggle("is-active", is30);
      if (btn90) btn90.classList.toggle("is-active", is90);
      if (btnAll) btnAll.classList.toggle("is-active", isAll);
    }

    function renderTerritoryHighlightHeader(setText, selectedUfCode) {
      if (selectedUfCode) {
        setText("terrHighlightTitle", "Cidades em destaque");
        setText("terrHighlightSubtitle", "Concentração urbana e oportunidades regionais.");
        return;
      }
      setText("terrHighlightTitle", "UFs em destaque");
      setText("terrHighlightSubtitle", "Distribuição entre unidades federativas no recorte atual.");
    }

    function renderTerritoryCoverageLabel(setText, selectedUfCode) {
      setText(
        "terrCoverageLabel",
        selectedUfCode
          ? "Cobertura por cidade (inscritos)"
          : "Cobertura por UF (inscritos)"
      );
    }

    function renderTerritoryUfButtons(setHtml, ufPairs = []) {
      const html = (ufPairs || []).length
        ? ufPairs.map(([ufLabel, count], idx) => {
            const ufCode = resolveUfCode(ufLabel);
            const ufFilterValue = String(ufLabel || "").trim();
            const label = ufCode || ufFilterValue || "UF";
            return `
              <button
                type="button"
                class="city-focus-btn"
                data-terr-uf-filter="${escapeHtml(ufFilterValue)}"
                title="Clique para filtrar esta UF"
              >
                <span class="city-focus-label">${idx + 1}. ${escapeHtml(label)}</span>
                <span class="city-focus-value">${fmtInt(count)}</span>
              </button>
            `;
          }).join("")
        : `<div class="text-sm text-slate-500">Sem dados por UF no recorte atual.</div>`;
      setHtml("topCitiesList", html);
    }

    function renderTerritoryCityButtons(setHtml, rows = []) {
      const html = (rows || []).length
        ? rows.map((p, idx) => `
          <button
            type="button"
            class="city-focus-btn ${state.mapCityFocus?.key === mapCityFocusKeyFromRow(p) ? "active" : ""}"
            data-map-city-focus-key="${escapeHtml(mapCityFocusKeyFromRow(p))}"
            data-map-city-focus-label="${escapeHtml(mapCityFocusLabelFromRow(p))}"
            data-map-city-focus-uf="${escapeHtml(resolveUfCode(p.uf) || "")}"
            title="Clique para destacar esta cidade no mapa"
          >
            <span class="city-focus-label">${idx + 1}. ${escapeHtml(mapCityFocusLabelFromRow(p))}</span>
            <span class="city-focus-value">${fmtInt(p.weight)}</span>
          </button>
        `).join("")
        : `<div class="text-sm text-slate-500">Sem dados de cidades para o recorte atual.</div>`;
      setHtml("topCitiesList", html);
    }

    function renderAggregated(setText, setHtml) {
      const raw = state.raw || {};
      const k = raw.kpis || {};
      const series = Array.isArray(raw.series_daily) ? raw.series_daily : [];
      const byUfRows = Array.isArray(raw.by_uf) ? raw.by_uf.filter((r)=>isValidUfValue(r?.uf)) : [];
      const byPubRows = Array.isArray(raw.by_publico) ? raw.by_publico : [];
      const byCityRows = Array.isArray(raw.by_cidade) ? raw.by_cidade.filter((r)=>isValidUfValue(r?.uf)) : [];
      const byCepRowsBase = Array.isArray(raw.by_cep) ? raw.by_cep.filter((r)=>normalizeCep(r?.cep)) : [];
      const byCepRows = hydrateByCepRows(byCepRowsBase);
      const topTiposRows = Array.isArray(raw.top_tipos) ? raw.top_tipos : [];
      const topItensRows = Array.isArray(raw.top_itens) ? raw.top_itens : [];

      const sIns = {
        labels: series.map((r)=>String(r.date || "")),
        values: series.map((r)=>Number(r.inscritos || 0))
      };
      const sAt = {
        labels: series.map((r)=>String(r.date || "")),
        values: series.map((r)=>Number(r.atendimentos || 0))
      };

      const byUfAt = byUfRows.map((r)=>[String(r.uf || "N/A"), Number(r.atendimentos || 0)]);
      const byPubAt = byPubRows.map((r)=>[String(r.publico || "N/A"), Number(r.atendimentos || 0)]);
      const topTipos = topTiposRows
        .map((r)=>[String(r.tipo || "N/A"), Number(r.qtd || 0)])
        .filter(([label]) => !isEventoType(label));
      const topItens = topItensRows.map((r)=>[String(r.nome_item || "N/A"), Number(r.qtd || 0)]);
      const macroPairsRaw = collectMacrotemaPairsFromItemPairs(topItens, topTipos);
      const competencyPairsRaw = collectCompetencyPairsFromItemPairs(topItens, state.competencyMode);
      const macroPairs = toPercentagePairs(macroPairsRaw, 10);
      const competencyPairs = toPercentagePairs(competencyPairsRaw, 10);
      const geoPointsByCep = buildGeoPointsFromByCep(byCepRows);
      const geoPointsByCity = buildGeoPointsFromByCidade(byCityRows);
      const geoPointsByUf = buildGeoPointsFromByUf(byUfRows);
      const selectedUfCode = resolveUfCode(state.filters.uf);
      const topCitiesLimit = 10;
      let geoPoints = [];
      if (!selectedUfCode) {
        // Sem UF selecionada: mapa deve operar somente com agregado por UF.
        geoPoints = geoPointsByUf;
      } else {
        if (geoPointsByCep.length && hasGeoPointForUf(geoPointsByCep, selectedUfCode)) {
          geoPoints = geoPointsByCep;
        } else if (geoPointsByCity.length && hasGeoPointForUf(geoPointsByCity, selectedUfCode)) {
          geoPoints = geoPointsByCity;
        } else {
          geoPoints = [];
        }
      }
      const topGeoCitiesByCity = aggregateTopCities(
        byCityRows.map((r) => ({
          cidade: r?.cidade,
          uf: r?.uf,
          weight: Number(r?.inscritos || r?.atendimentos || r?.ativos || 0),
        })),
        topCitiesLimit
      );
      const topGeoCitiesByCep = aggregateTopCities(
        byCepRows.map((r) => ({
          cep: r?.cep,
          cidade: r?.cidade,
          uf: r?.uf,
          weight: Number(r?.inscritos || r?.atendimentos || 0),
        })),
        topCitiesLimit
      );
      const topGeoCities = topGeoCitiesByCity.length
        ? topGeoCitiesByCity
        : (topGeoCitiesByCep.length ? topGeoCitiesByCep : aggregateTopCities(geoPoints, topCitiesLimit));
      const topGeoCitiesOrdered = [...topGeoCities].sort((a, b) => {
        const wa = Number(a?.weight || 0);
        const wb = Number(b?.weight || 0);
        if (wb !== wa) return wb - wa;
        const la = mapCityFocusLabelFromRow(a);
        const lb = mapCityFocusLabelFromRow(b);
        return String(la).localeCompare(String(lb), "pt-BR");
      });
      const ufCoverage = computeUfCoverageFromRows(byCityRows, state.filters.uf, {
        byUfRows,
        metaCoverage: raw?.meta?.coverage,
      });

      const selectedUfMetrics = selectedUfCode
        ? byUfRows.find((r) => resolveUfCode(r?.uf) === selectedUfCode) || null
        : null;
      const inscritos = selectedUfMetrics ? Number(selectedUfMetrics.inscritos || 0) : Number(k.inscritos || 0);
      const atendimentos = selectedUfMetrics ? Number(selectedUfMetrics.atendimentos || 0) : Number(k.atendimentos || 0);
      const membrosAtivos = selectedUfMetrics ? Number(selectedUfMetrics.ativos || 0) : Number(k.membros_ativos || 0);
      const convRatioBackend = clamp(Number(k.conversao_pct || 0) / 100, 0, 1);
      const convRatio = selectedUfMetrics ? convRatioBackend : convRatioBackend;
      const atendidosBase = Number(k.atendidos || 0);
      const atendidos = selectedUfMetrics
        ? Math.round(inscritos * convRatio)
        : atendidosBase;

      setText("kpiAtend", fmtInt(atendimentos));
      setText("kpiAtivos", fmtInt(inscritos));
      setText("kpiConv", fmtPct(convRatio));
      setText("kpiAtendTarget", fmtInt(KPI_TARGETS.atendimentos));
      setText("kpiAtivosTarget", fmtInt(KPI_TARGETS.inscritos));
      setText("kpiConvTarget", fmtPct(KPI_TARGETS.conversaoAtendimento));
      updateProgress("kpiAtendBar", atendimentos, KPI_TARGETS.atendimentos);
      updateProgress("kpiAtivosBar", inscritos, KPI_TARGETS.inscritos);
      updateProgress("kpiConvBar", convRatio, KPI_TARGETS.conversaoAtendimento);
      updateDeltaEl("kpiAtendDelta", atendimentos, 0);
      updateDeltaEl("kpiAtivosDelta", inscritos, 0);
      updateDeltaEl("kpiConvDelta", convRatio, 0);

      const insStats = seriesStats(sIns.labels, sIns.values);
      const atStats = seriesStats(sAt.labels, sAt.values);
      const topUf = byUfAt[0];
      const topShare = shareConcentration(byUfAt);
      const topMacro = macroPairs[0];
      const topCompetency = competencyPairs[0];

      setText("inscrPeak", `${fmtInt(insStats.maxVal)} em ${fmtDateBr(insStats.maxLabel)}`);
      setText("inscrAvg", `${fmtTrunc1(insStats.avg)} / dia`);
      setText("atendAvg", `${fmtTrunc1(atStats.avg)} / dia`);
      setText("atendTopUf", topUf ? `${topUf[0]} (${fmtInt(topUf[1])})` : "-");
      setText("atendTopShare", `5 UFs: ${fmtPct(topShare.top5)}`);
      setText("macroTopLabel", topMacro ? `${topMacro[0]} (${fmtPct(Number(topMacro[1] || 0) / 100)})` : "-");
      setText(
        "competencyTopLabel",
        topCompetency ? `${topCompetency[0]} (${fmtPct(Number(topCompetency[1] || 0) / 100)})` : "-"
      );

      const summary = [
        `Volume do periodo: ${fmtInt(atendimentos)} atendimentos e ${fmtInt(inscritos)} inscritos.`,
        `Atendidos unicos: ${fmtInt(atendidos)}. Membros ativos: ${fmtInt(membrosAtivos)}.`,
        `Conversao em ${fmtPct(convRatio)} no recorte atual.`
      ];
      setHtml("summaryList", summary.map((line)=>`<li>${line}</li>`).join(""));

      const flags = [];
      if (topShare.top5 >= 0.75) flags.push("Alta concentracao territorial nas 5 UFs lideres.");
      if (convRatio < 0.2) flags.push("Conversao abaixo de 20% no recorte atual.");
      if (!flags.length) flags.push("Sem alertas criticos no recorte atual.");
      setHtml("insightsList", flags.map((line)=>`<li>${line}</li>`).join(""));

      renderTerritoryHighlightHeader(setText, selectedUfCode);
      if (selectedUfCode) {
        renderTerritoryCityButtons(setHtml, topGeoCitiesOrdered);
      } else {
        renderTerritoryUfButtons(setHtml, byUfAt.slice(0, 10));
      }
      setText("funnelInscr", fmtInt(inscritos));
      setText("funnelAtend", fmtInt(atendimentos));
      setText("funnelAtendPct", fmtPct(convRatio));
      updateProgress("funnelAtendBar", atendidos, inscritos || 1);
      setHtml(
        "topMixList",
        topTipos.slice(0, 5).map(([label, count]) => `
          <li class="flex items-center justify-between text-sm">
            <span>${toSentenceCase(label)}</span>
            <span class="text-slate-500">${fmtInt(count)}</span>
          </li>
        `).join("") || `<li class="text-sm text-slate-500">Sem combinacoes no recorte atual.</li>`
      );

      if (state.page === "overview") {
        renderLineChart("chartInscrLine", sIns.labels, sIns.values, "Inscritos");
        renderMapPoints("map", geoPoints);
        renderUfPills(byUfAt);
        renderDoughnut("chartMacro", macroPairs, "Macrotema", { percentMode: true });
        renderDoughnut("chartMaterial", competencyPairs, `Competências (${competencyModeLabel(state.competencyMode)})`, { percentMode: true });
      }

      if (state.page === "territory") {
        const byCityAtPrimary = selectedUfCode
          ? aggregateCityMetricPairs(byCityRows, selectedUfCode, "atendimentos", 10)
          : [];
        const byCityAt = selectedUfCode
          ? (byCityAtPrimary.length ? byCityAtPrimary : aggregateCityMetricPairs(byCepRows, selectedUfCode, "atendimentos", 10))
          : [];
        const territoryPairs = selectedUfCode ? byCityAt : byUfAt.slice(0, 10);
        const territoryChartTitle = selectedUfCode
          ? "Atendimentos por cidade (10 maiores)"
          : "Atendimentos por UF (10 maiores)";
        renderBarChart("chartUfAtend2", territoryPairs, territoryChartTitle, {
          topBarLabels: Boolean(selectedUfCode)
        });
        setText("terrRankTitle", territoryChartTitle);
        renderMapPoints("mapTerritory", geoPoints);
        setText("terrUfs", `${byUfRows.length} UFs`);
        setText("terrCities", "—");
        setText("terrUsers", fmtInt(inscritos));
        setText("terrAtendDay", fmtInt(Math.round(atStats.avg)));
        renderTerritoryCoverageLabel(setText, selectedUfCode);
        setText("terrUfCoverage", ufCoverage.text);
        if (selectedUfCode) renderMapPoints("mapTerritory", geoPoints);
      }

      if (state.page === "engagement") {
        renderLineChart("chartAtendLine", sAt.labels, sAt.values, "Atendimentos");
        renderDoughnut("chartPublico", byPubAt, "Publico");
        renderDoughnut("chartChannels", [], "Canais");
      }

      if (state.page === "content") {
        renderDoughnut("chartMacroBar", macroPairs, "Macrotemas", { percentMode: true });
        renderDoughnut("chartMatBar", competencyPairs, `Competências (${competencyModeLabel(state.competencyMode)})`, { percentMode: true });
      }

    }

    function render() {
      const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      };
      const setHtml = (id, html) => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = html;
      };

      const coverage = computeCoverage(state.filtered);

      // nav active
      document.querySelectorAll("[data-nav]").forEach(btn => {
        const active = btn.getAttribute("data-nav") === state.page;
        btn.classList.toggle("nav-active", active);
        btn.setAttribute("aria-current", active ? "page" : "false");
      });

      // show page
      document.querySelectorAll("[data-page]").forEach(sec => {
        sec.classList.toggle("hidden", sec.getAttribute("data-page") !== state.page);
      });
      syncCompetencyModeControls();

      const capEl = document.getElementById("dataCapLabel");
      if (capEl) {
        const cap = state.raw?.meta?.cap;
        if (cap?.truncated) {
          capEl.classList.remove("hidden");
          capEl.textContent = `Exibindo primeiros ${fmtInt(cap.returned)} registros (limite ${fmtInt(cap.limit)}).`;
        } else {
          capEl.classList.add("hidden");
          capEl.textContent = "";
        }
      }

      if (isAggregatedPayload(state.raw)) {
        renderAggregated(setText, setHtml);
        syncPresetButtons();
        renderIconsNow();
        return;
      }

      // KPIs + insights
      const ins = insights(state.filtered);
      setText("kpiAtend", fmtInt(ins.kpis.atendimentos));
      setText("kpiAtivos", fmtInt(ins.kpis.inscritos));
      setText("kpiConv", fmtPct(ins.kpis.conversaoAtendimento));

      setText("kpiAtendTarget", fmtInt(KPI_TARGETS.atendimentos));
      setText("kpiAtivosTarget", fmtInt(KPI_TARGETS.inscritos));
      setText("kpiConvTarget", fmtPct(KPI_TARGETS.conversaoAtendimento));

      updateProgress("kpiAtendBar", ins.kpis.atendimentos, KPI_TARGETS.atendimentos);
      updateProgress("kpiAtivosBar", ins.kpis.inscritos, KPI_TARGETS.inscritos);
      updateProgress("kpiConvBar", ins.kpis.conversaoAtendimento, KPI_TARGETS.conversaoAtendimento);

      const prev = computePreviousKpis();
      updateDeltaEl("kpiAtendDelta", ins.kpis.atendimentos, prev?.kpis.atendimentos || 0);
      updateDeltaEl("kpiAtivosDelta", ins.kpis.inscritos, prev?.kpis.inscritos || 0);
      updateDeltaEl("kpiConvDelta", ins.kpis.conversaoAtendimento, prev?.kpis.conversaoAtendimento || 0);

      const sIns = seriesByDate(state.filtered, "inscricao");
      const sAt = seriesByDate(state.filtered, "atendimento");
      const insStats = seriesStats(sIns.labels, sIns.values);
      const atStats = seriesStats(sAt.labels, sAt.values);
      const topUf = ins.byUfAt[0];
      const topShare = shareConcentration(ins.byUfAt);
      const macroPairsRaw = collectMacrotemaPairsFromEvents(state.filtered);
      const competencyPairsRaw = collectCompetencyPairsFromEvents(state.filtered, state.competencyMode);
      const macroPairs = toPercentagePairs(macroPairsRaw, 10);
      const competencyPairs = toPercentagePairs(competencyPairsRaw, 10);
      const macroTop = macroPairs[0];
      const topCompetency = competencyPairs[0];

      setText("inscrPeak", `${fmtInt(insStats.maxVal)} em ${fmtDateBr(insStats.maxLabel)}`);
      setText("inscrAvg", `${fmtTrunc1(insStats.avg)} / dia`);
      setText("atendAvg", `${fmtTrunc1(atStats.avg)} / dia`);
      setText("atendTopUf", topUf ? `${topUf[0]} (${fmtInt(topUf[1])})` : "-");
      setText("atendTopShare", `5 UFs: ${fmtPct(topShare.top5)}`);
      setText("macroTopLabel", macroTop ? `${macroTop[0]} (${fmtPct(Number(macroTop[1] || 0) / 100)})` : "-");
      setText(
        "competencyTopLabel",
        topCompetency ? `${topCompetency[0]} (${fmtPct(Number(topCompetency[1] || 0) / 100)})` : "-"
      );

      const summary = buildSummary(state.filtered, state.competencyMode);
      const summaryHtml = summary.map((line) => `<li>${line}</li>`).join("");
      setHtml("summaryList", summaryHtml);
      const insightHtml = ins.flags.length
        ? ins.flags.map((line) => `<li>${line}</li>`).join("")
        : `<li>Sem alertas críticos no recorte atual.</li>`;
      setHtml("insightsList", insightHtml);

      const selectedUfCode = resolveUfCode(state.filters.uf);
      const topCitiesLimit = 10;
      const mapCityRows = selectedUfCode
        ? buildLeafletHeatCells(state.filtered, selectedUfCode, "")
        : [];
      const topGeoCities = selectedUfCode
        ? [...mapCityRows]
            .sort((a, b) => {
              const wa = Number(a?.weight || 0);
              const wb = Number(b?.weight || 0);
              if (wb !== wa) return wb - wa;
              return String(mapCityFocusLabelFromRow(a)).localeCompare(String(mapCityFocusLabelFromRow(b)), "pt-BR");
            })
            .slice(0, topCitiesLimit)
        : [];
      renderTerritoryHighlightHeader(setText, selectedUfCode);
      if (selectedUfCode) {
        renderTerritoryCityButtons(setHtml, topGeoCities);
      } else {
        renderTerritoryUfButtons(setHtml, ins.byUfAt.slice(0, 10));
      }

      setText("funnelInscr", fmtInt(ins.kpis.inscritos));
      setText("funnelAtend", fmtInt(ins.kpis.atendimentos));
      setText("funnelAtendPct", fmtPct(ins.kpis.conversaoAtendimento));
      updateProgress("funnelAtendBar", ins.kpis.atendidos, ins.kpis.inscritos || 1);

      const topMix = topByCombo(state.filtered, "macrotema", "material_type", 5);
      const topMixHtml = topMix.length ? topMix.map(([label, count]) => `
        <li class="flex items-center justify-between text-sm">
          <span>${label}</span>
          <span class="text-slate-500">${fmtInt(count)}</span>
        </li>
      `).join("") : `<li class="text-sm text-slate-500">Sem combinacoes no recorte atual.</li>`;
      setHtml("topMixList", topMixHtml);

      // Charts por pagina
      if (state.page === "overview") {
        renderLineChart("chartInscrLine", sIns.labels, sIns.values, "Inscricoes");
        renderMapPoints("map", state.filtered);
        const topUfGlobal = topByKey(state.filtered, "uf", (e)=>e.type==="atendimento" && isValidUfValue(e.uf), 27);
        renderUfPills(topUfGlobal);
        renderDoughnut("chartMacro", macroPairs, "Macrotema", { percentMode: true });
        renderDoughnut("chartMaterial", competencyPairs, `Competências (${competencyModeLabel(state.competencyMode)})`, { percentMode: true });
      }

      if (state.page === "territory") {
        const cityAtPairs = selectedUfCode
          ? topByKey(
              state.filtered,
              "city",
              (e) => e.type === "atendimento" && isValidCityValue(e.city),
              10
            )
              .filter(([label, count]) => String(label || "").trim() && Number(count || 0) > 0)
              .map(([city, count]) => [`${String(city)} (${selectedUfCode})`, Number(count || 0)])
          : [];
        const territoryPairs = selectedUfCode ? cityAtPairs : ins.byUfAt.slice(0, 10);
        const territoryChartTitle = selectedUfCode
          ? "Atendimentos por cidade (10 maiores)"
          : "Atendimentos por UF (10 maiores)";
        renderBarChart("chartUfAtend2", territoryPairs, territoryChartTitle, {
          topBarLabels: Boolean(selectedUfCode)
        });
        setText("terrRankTitle", territoryChartTitle);
        renderMapPoints("mapTerritory", state.filtered);
        setText("terrUfs", `${coverage.ufs} UFs`);
        setText("terrCities", "—");
        setText("terrUsers", fmtInt(coverage.users));
        setText("terrAtendDay", fmtInt(Math.round(coverage.atendPerDay)));
        const ufCoverage = computeUfCoverageFromEvents(state.filtered, state.filters.uf);
        renderTerritoryCoverageLabel(setText, selectedUfCode);
        setText("terrUfCoverage", ufCoverage.text);
        if (selectedUfCode) renderMapPoints("mapTerritory", state.filtered);
      }

      if (state.page === "engagement") {
        renderLineChart("chartAtendLine", sAt.labels, sAt.values, "Atendimentos");
        const topPub = topByKey(state.filtered, "publico", null, 10);
        renderDoughnut("chartPublico", topPub, "Publico");
        const topChannel = topByKey(state.filtered, "channel", null, 10);
        renderDoughnut("chartChannels", topChannel, "Canais");
      }

      if (state.page === "content") {
        const topMacro = macroPairs;
        renderDoughnut("chartMacroBar", topMacro, "Macrotemas", { percentMode: true });
        renderDoughnut("chartMatBar", competencyPairs, `Competências (${competencyModeLabel(state.competencyMode)})`, { percentMode: true });
      }

      syncPresetButtons();
      renderIconsNow();
    }

    function getPdfReportData() {
      const period = `${fmtDateBr(state.filters.dateFrom)} a ${fmtDateBr(state.filters.dateTo)}`;
      const filtroUf = state.filters.uf || "Todos";
      const filtroPublico = state.filters.publico || "Todos";

      if (isAggregatedPayload(state.raw)) {
        const raw = state.raw || {};
        const k = raw.kpis || {};
        const byUf = (raw.by_uf || []).map((r) => [String(r.uf || "N/A"), Number(r.atendimentos || 0)]).slice(0, 5);
        const byPub = (raw.by_publico || []).map((r) => [String(r.publico || "N/A"), Number(r.atendimentos || 0)]).slice(0, 5);
        const tipos = (raw.top_tipos || [])
          .map((r) => [toSentenceCase(String(r.tipo || "N/A")), Number(r.qtd || 0)])
          .filter(([label]) => !isEventoType(label))
          .slice(0, 5);
        const itens = (raw.top_itens || []).map((r) => [String(r.nome_item || "N/A"), Number(r.qtd || 0)]).slice(0, 5);

        return {
          period,
          filtroUf,
          filtroPublico,
          inscritos: Number(k.inscritos || 0),
          atendimentos: Number(k.atendimentos || 0),
          atendidos: Number(k.atendidos || 0),
          conversao: Number(k.conversao_pct || 0) / 100,
          byUf,
          byPub,
          tipos,
          itens,
        };
      }

      const ins = insights(state.filtered);
      const tipos = topByKey(state.filtered, "type", (e) => !isEventoType(e.type), 5)
        .map(([label, count]) => [toSentenceCase(label), count]);
      const itens = topByKey(state.filtered, "material_type", null, 5);
      const byPub = topByKey(state.filtered, "publico", null, 5);

      return {
        period,
        filtroUf,
        filtroPublico,
        inscritos: Number(ins.kpis.inscritos || 0),
        atendimentos: Number(ins.kpis.atendimentos || 0),
        atendidos: Number(ins.kpis.atendidos || 0),
        conversao: Number(ins.kpis.conversaoAtendimento || 0),
        byUf: ins.byUfAt.slice(0, 5),
        byPub,
        tipos,
        itens,
      };
    }

    async function waitForCaptureAssets(root, timeoutMs = 2800) {
      if (!root) return;
      const imgs = Array.from(root.querySelectorAll("img"));
      if (!imgs.length) return;
      await Promise.all(
        imgs.map((img) => {
          if (img.complete) return Promise.resolve();
          return new Promise((resolve) => {
            let done = false;
            const finish = () => {
              if (done) return;
              done = true;
              resolve();
            };
            img.addEventListener("load", finish, { once: true });
            img.addEventListener("error", finish, { once: true });
            setTimeout(finish, timeoutMs);
          });
        })
      );
    }

    async function preparePageForPdfCapture(page) {
      state.page = page;
      render();
      await wait(140);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      if (page === "overview" || page === "territory") {
        maps.forEach((ctx) => {
          if (ctx?.map && isRenderableMapHost(ctx?.host)) {
            ctx.map.invalidateSize({ pan: false, animate: false });
          }
        });
      }
      await wait(260);
      await new Promise((resolve) => requestAnimationFrame(resolve));
    }

    function setPdfCaptureMode(enabled) {
      document.body.classList.toggle("pdf-capture-mode", !!enabled);
    }

    async function captureNodeForPdf(root, scale = 1.5) {
      const chartCanvasIds = [
        "chartInscrLine",
        "chartMacro",
        "chartMaterial",
        "chartUfAtend2",
        "chartAtendLine",
        "chartPublico",
        "chartChannels",
        "chartMacroBar",
        "chartMatBar",
      ];

      const chartSnapshots = new Map();
      for (const id of chartCanvasIds) {
        const canvas = document.getElementById(id);
        if (!canvas || !canvas.width || !canvas.height) continue;
        try {
          chartSnapshots.set(id, canvas.toDataURL("image/png"));
        } catch (e) {
          console.warn("[UI] [pdf] chart snapshot skipped", { id, err: String(e) });
        }
      }

      const shouldIgnoreElement = (el) => {
        if (!el) return false;
        const tag = String(el.tagName || "").toUpperCase();
        if (tag === "CANVAS" && el.closest(".leaflet-container")) return true;
        if (tag === "IMG") {
          const src = String(el.getAttribute("src") || "").trim();
          if (/^https?:\/\//i.test(src)) return true;
          if (el.closest(".leaflet-tile-pane")) return true;
        }
        return false;
      };

      const baseOptions = {
        backgroundColor: "#f4f7ff",
        logging: false,
        scale,
        width: root.scrollWidth,
        height: root.scrollHeight,
        windowWidth: root.scrollWidth,
        windowHeight: root.scrollHeight,
        scrollX: 0,
        scrollY: 0,
        imageTimeout: 2800,
        ignoreElements: shouldIgnoreElement,
        onclone: (cloneDoc) => {
          // 1) remove elementos remotos do mapa (tiles/controles)
          cloneDoc.querySelectorAll(".leaflet-tile-pane, .leaflet-control-container").forEach((el) => {
            el.remove();
          });

          // 2) trocar canvases de graficos por imagens estaticas
          for (const [id, dataUrl] of chartSnapshots.entries()) {
            const c = cloneDoc.getElementById(id);
            if (!c || !c.parentNode) continue;
            const img = cloneDoc.createElement("img");
            img.src = dataUrl;
            img.alt = id;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.display = "block";
            img.style.objectFit = "contain";
            c.parentNode.replaceChild(img, c);
          }

          // 3) remover qualquer canvas remanescente para evitar taint
          cloneDoc.querySelectorAll("canvas").forEach((c) => c.remove());
        },
      };

      try {
        const canvas = await window.html2canvas(root, {
          ...baseOptions,
          useCORS: true,
          allowTaint: false,
        });
        try {
          const ctx = canvas.getContext("2d");
          if (ctx && canvas.width > 0 && canvas.height > 0) {
            ctx.getImageData(0, 0, 1, 1);
          }
        } catch (probeErr) {
          throw new Error(`CAPTURE_TAINTED:${String(probeErr)}`);
        }
        return canvas;
      } catch (err) {
        console.warn("[UI] [pdf] capture fallback (ignore remote images)", { err: String(err) });
        const canvas = await window.html2canvas(root, {
          ...baseOptions,
          useCORS: false,
          allowTaint: false,
        });
        return canvas;
      }
    }

    function appendCanvasToPdf(doc, canvas, addNewPageBefore = false) {
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const margin = 14;
      const drawW = pageW - (margin * 2);
      const drawH = pageH - (margin * 2);
      const slicePixelH = Math.max(1, Math.floor((canvas.width * drawH) / drawW));
      let offsetY = 0;
      let firstSlice = true;

      while (offsetY < canvas.height) {
        if (addNewPageBefore || !firstSlice) doc.addPage();
        const cutH = Math.min(slicePixelH, canvas.height - offsetY);
        const temp = document.createElement("canvas");
        temp.width = canvas.width;
        temp.height = cutH;
        const tctx = temp.getContext("2d", { alpha: false });
        if (!tctx) throw new Error("Falha ao preparar imagem para PDF.");
        tctx.drawImage(canvas, 0, offsetY, canvas.width, cutH, 0, 0, canvas.width, cutH);
        let img = "";
        try {
          img = temp.toDataURL("image/jpeg", 0.95);
        } catch (e) {
          throw new Error(`PDF_SLICE_TAINTED:${String(e)}`);
        }
        const renderH = (cutH * drawW) / canvas.width;
        doc.addImage(img, "JPEG", margin, margin, drawW, renderH, undefined, "FAST");
        offsetY += cutH;
        firstSlice = false;
        addNewPageBefore = true;
      }

      return true;
    }

    async function exportPdfViaBrowserPrint() {
      const filterModal = document.getElementById("filterModal");
      if (filterModal) {
        filterModal.classList.add("hidden");
        filterModal.setAttribute("aria-hidden", "true");
      }
      closeUfWelcomeModal();
      syncModalBackdropState();
      await wait(120);
      window.print();
    }

    async function exportPdfReport() {
      if (!window.jspdf || typeof window.jspdf.jsPDF !== "function") {
        showToast("Biblioteca de PDF indisponivel no momento.", "warning");
        return;
      }
      if (typeof window.html2canvas !== "function") {
        showToast("Biblioteca de captura visual indisponivel no momento.", "warning");
        return;
      }

      const captureRoot = document.querySelector("#app .content-wrap > div");
      if (!captureRoot) {
        showToast("Nao foi possivel localizar a area do dashboard para exportacao.", "warning");
        return;
      }

      const stamp = new Date().toISOString().slice(0, 19).replaceAll(":", "-");
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "pt", format: "a4", orientation: "portrait" });
      const pagesForExport = ["overview", "territory", "engagement", "content"];
      const prevPage = state.page;
      const prevHash = location.hash;
      let shouldAddPage = false;

      try {
        setLoadingState(true);
        setBootLoadingGate(true, "Gerando PDF visual do dashboard...");
        setPdfCaptureMode(true);
        closeUfWelcomeModal();
        const filterModal = document.getElementById("filterModal");
        if (filterModal) {
          filterModal.classList.add("hidden");
          filterModal.setAttribute("aria-hidden", "true");
        }
        syncModalBackdropState();

        for (const page of pagesForExport) {
          await preparePageForPdfCapture(page);
          await waitForCaptureAssets(captureRoot);
          const scale = Math.max(1, Math.min(2, Number(window.devicePixelRatio || 1.5)));
          const canvas = await captureNodeForPdf(captureRoot, scale);
          shouldAddPage = appendCanvasToPdf(doc, canvas, shouldAddPage);
        }

        doc.save(`escalada_relatorio_visual_${stamp}.pdf`);
        showToast("PDF visual exportado com sucesso.", "success");
      } catch (err) {
        console.error("[UI] [pdf] export failed", { err: String(err), stack: String(err?.stack || "") });
        const errText = String(err || "");
        const isSecurityBlock = errText.includes("SecurityError") || errText.includes("TAINTED");
        if (isSecurityBlock) {
          setPdfCaptureMode(false);
          setBootLoadingGate(false);
          setLoadingState(false);
          showToast("Bloqueio de seguranca no export direto. Abrindo impressao para salvar em PDF.", "warning");
          await exportPdfViaBrowserPrint();
          return;
        }
        showToast("Falha ao gerar PDF visual.", "warning");
      } finally {
        state.page = prevPage;
        location.hash = prevHash;
        render();
        setPdfCaptureMode(false);
        setBootLoadingGate(false);
        setLoadingState(false);
      }
    }

    // =========================================================
    // Boot
    // =========================================================
    function fillFilterOptions() {
      const events = state.raw?.events || [];
      const metaUfs = state.raw?.meta?.available_ufs;
      const metaPublicos = state.raw?.meta?.available_publicos;
      const byUf = state.raw?.by_uf;
      const byPublico = state.raw?.by_publico;
      const snapshotUfs = state.ufPillsValueByCode instanceof Map
        ? Array.from(state.ufPillsValueByCode.values()).filter(isValidUfValue)
        : [];
      const primaryUfs = Array.isArray(metaUfs) && metaUfs.length
        ? metaUfs.filter(isValidUfValue)
        : (
            Array.isArray(byUf) && byUf.length
              ? byUf.map((x)=>x.uf).filter(isValidUfValue)
              : events.map((e)=>e.uf).filter(isValidUfValue)
          );
      const allUfOptions = Object.keys(UF_CENTROIDS)
        .map((code) => {
          const fromSnapshot = state.ufPillsValueByCode instanceof Map ? state.ufPillsValueByCode.get(code) : "";
          return String(fromSnapshot || UF_CODE_TO_NAME[code] || code).trim();
        })
        .filter(isValidUfValue);
      const ufs = mergeUfOptions(primaryUfs, snapshotUfs, allUfOptions);
      const pubs = Array.isArray(metaPublicos) && metaPublicos.length
        ? uniq(metaPublicos.filter(Boolean))
        : (
            Array.isArray(byPublico) && byPublico.length
              ? uniq(byPublico.map((x)=>x.publico).filter(Boolean))
              : uniq(events.map((e)=>e.publico).filter(Boolean))
          );

      const ufSel = document.getElementById("fUf");
      if (!ufSel) return;
      ufSel.innerHTML = `<option value="Todos">Todos</option>`;
      for (const uf of ufs) {
        const opt = document.createElement("option");
        opt.value = uf;
        opt.textContent = uf;
        ufSel.appendChild(opt);
      }

      const pubSel = document.getElementById("fPublico");
      if (pubSel) {
        pubSel.innerHTML = `<option value="Todos">Todos</option>` + pubs.map((p)=>`<option>${p}</option>`).join("");
      }

      if (isValidUfValue(state.filters.uf)) {
        const currentCode = resolveUfCode(state.filters.uf);
        const canonical = ufs.find((u) => resolveUfCode(u) === currentCode);
        if (canonical) {
          state.filters.uf = canonical;
        } else if (!ufs.includes(state.filters.uf)) {
          state.filters.uf = "Todos";
        }
      } else {
        state.filters.uf = "Todos";
      }
      if (!pubs.includes(state.filters.publico)) state.filters.publico = "Todos";
      syncFilterForm();
    }

    function syncModalBackdropState() {
      const filterModal = document.getElementById("filterModal");
      const ufModal = document.getElementById("ufWelcomeModal");
      const hasOpenModal = [filterModal, ufModal].some((el) => el && !el.classList.contains("hidden"));
      document.body.classList.toggle("modal-open", hasOpenModal);
    }

    function getUfWelcomeOptions() {
      const base = Object.keys(UF_CENTROIDS)
        .map((code) => {
          const fromSnapshot = state.ufPillsValueByCode instanceof Map ? state.ufPillsValueByCode.get(code) : "";
          return String(fromSnapshot || UF_CODE_TO_NAME[code] || code).trim();
        })
        .filter(isValidUfValue);
      const metaUfs = state.raw?.meta?.available_ufs;
      const byUf = state.raw?.by_uf;
      const byUfOptions = Array.isArray(byUf) ? byUf.map((r) => r?.uf) : [];
      return mergeUfOptions(metaUfs, byUfOptions, base);
    }

    function populateUfWelcomeList() {
      const list = document.getElementById("ufWelcomeList");
      if (!list) return;
      const options = getUfWelcomeOptions();
      if (!options.length) {
        list.innerHTML = `<div class="text-sm text-slate-500">Nenhuma UF disponivel no momento.</div>`;
        return;
      }
      list.innerHTML = "";
      for (const uf of options) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "uf-onboarding-item";
        btn.textContent = uf;
        btn.addEventListener("click", () => {
          const today = normalizeDateYmd(new Date().toISOString().slice(0, 10));
          const from = state.fullRange.from || state.filters.dateFrom || today;
          const to = state.fullRange.to || state.filters.dateTo || from;
          applyFilters(
            { uf, dateFrom: from, dateTo: to, publico: state.filters.publico || "Todos" },
            { immediate: true, reason: "onboarding-uf-select" }
          );
          closeUfWelcomeModal();
          showToast(`UF ${uf} aplicada com periodo completo.`, "success");
        });
        list.appendChild(btn);
      }
    }

    function openUfWelcomeModal() {
      if (!state.ufOnboardingUnlocked) return;
      const modal = document.getElementById("ufWelcomeModal");
      if (!modal) return;
      const gate = document.getElementById("authGate");
      if (gate && !gate.classList.contains("hidden")) return;
      populateUfWelcomeList();
      modal.classList.remove("hidden");
      modal.setAttribute("aria-hidden", "false");
      syncModalBackdropState();
    }

    function unlockUfOnboarding() {
      state.ufOnboardingUnlocked = true;
      setBootLoadingGate(false);
      openUfWelcomeModal();
    }

    function lockUfOnboarding(message = "Aguardando retorno do banco de dados...") {
      state.ufOnboardingUnlocked = false;
      closeUfWelcomeModal();
      setBootLoadingGate(true, message);
    }

    async function tryUnlockUfOnboardingFromRpc(reason = "boot-gate") {
      lockUfOnboarding("Carregando dados mais recentes...");
      const ok = await refreshFromServer({ reason, showLoadingToast: false });
      if (ok && state.lastLoadSource === "rpc") {
        unlockUfOnboarding();
        return true;
      }
      const authGate = document.getElementById("authGate");
      if (authGate && !authGate.classList.contains("hidden")) {
        setBootLoadingGate(false);
        return false;
      }
      lockUfOnboarding("Aguardando retorno 200 do banco para liberar a escolha de UF.");
      return false;
    }

    function closeUfWelcomeModal() {
      const modal = document.getElementById("ufWelcomeModal");
      if (!modal) return;
      modal.classList.add("hidden");
      modal.setAttribute("aria-hidden", "true");
      syncModalBackdropState();
    }

    function toggleMapCityFocus(payload) {
      const key = String(payload?.key || "").trim();
      if (!key) return;
      if (state.mapCityFocus?.key === key) {
        state.mapCityFocus = null;
      } else {
        state.mapCityFocus = {
          key,
          label: String(payload?.label || "").trim(),
          uf: resolveUfCode(payload?.uf) || "",
        };
      }
      render();
    }

    function bindTopCitiesListInteractions() {
      const list = document.getElementById("topCitiesList");
      if (!list || list.dataset.boundClick === "1") return;
      list.dataset.boundClick = "1";
      list.addEventListener("click", (ev) => {
        const ufBtn = ev.target?.closest?.("[data-terr-uf-filter]");
        if (ufBtn) {
          ev.preventDefault();
          const uf = String(ufBtn.getAttribute("data-terr-uf-filter") || "").trim();
          if (!uf) return;
          applyFilters({ uf }, { immediate: true, reason: "territory-uf-highlight" });
          return;
        }

        const btn = ev.target?.closest?.("[data-map-city-focus-key]");
        if (!btn) return;
        ev.preventDefault();
        toggleMapCityFocus({
          key: btn.getAttribute("data-map-city-focus-key"),
          label: btn.getAttribute("data-map-city-focus-label"),
          uf: btn.getAttribute("data-map-city-focus-uf"),
        });
      });
    }

    function wireUi() {
      // nav
      document.querySelectorAll("[data-nav]").forEach(btn => {
        btn.addEventListener("click", (e) => {
          if (btn.tagName.toLowerCase() === "a") e.preventDefault();
          setPage(btn.getAttribute("data-nav"));
        });
      });
      bindTopCitiesListInteractions();

      const bindCompetencyToggle = (id, mode) => {
        const btn = document.getElementById(id);
        if (!btn || btn.dataset.boundClick === "1") return;
        btn.dataset.boundClick = "1";
        btn.addEventListener("click", () => setCompetencyMode(mode));
      };
      bindCompetencyToggle("btnCompModeBncc", COMPETENCY_MODES.BNCC);
      bindCompetencyToggle("btnCompModeEntrecomp", COMPETENCY_MODES.ENTRECOMP);
      bindCompetencyToggle("btnCompModeBnccContent", COMPETENCY_MODES.BNCC);
      bindCompetencyToggle("btnCompModeEntrecompContent", COMPETENCY_MODES.ENTRECOMP);
      syncCompetencyModeControls();

      // filtros
      const bind = (id, fn) => {
        const el = document.getElementById(id);
        if (el) el.addEventListener("input", fn);
      };

      bind("fFrom", (e)=>applyFilters({ dateFrom: e.target.value }, { reason: "field-date-from" }));
      bind("fTo", (e)=>applyFilters({ dateTo: e.target.value }, { reason: "field-date-to" }));

      const fUf = document.getElementById("fUf");
      if (fUf) {
        fUf.addEventListener("change", (e)=>{
          applyFilters({ uf: e.target.value }, { reason: "field-uf" });
        });
      }

      const fPublico = document.getElementById("fPublico");
      if (fPublico) {
        fPublico.addEventListener("change", (e)=> {
          applyFilters({ publico: e.target.value }, { reason: "field-publico" });
        });
      }

      const applyPreset = (days) => {
        if (!state.fullRange.from || !state.fullRange.to) return;
        const patch = {};
        if (days === "all") {
          patch.dateFrom = state.fullRange.from;
          patch.dateTo = state.fullRange.to;
        } else {
          let from = shiftDate(state.fullRange.to, -days + 1);
          if (from < state.fullRange.from) from = state.fullRange.from;
          patch.dateFrom = from;
          patch.dateTo = state.fullRange.to;
        }
        applyFilters(patch, { immediate: true, reason: `preset-${days}` });
      };

      const btnPreset30 = document.getElementById("btnPreset30");
      const btnPreset90 = document.getElementById("btnPreset90");
      const btnPresetAll = document.getElementById("btnPresetAll");
      const btnClearUf = document.getElementById("btnClearUf");
      if (btnPreset30) btnPreset30.addEventListener("click", () => applyPreset(30));
      if (btnPreset90) btnPreset90.addEventListener("click", () => applyPreset(90));
      if (btnPresetAll) btnPresetAll.addEventListener("click", () => applyPreset("all"));
      if (btnClearUf) btnClearUf.addEventListener("click", () => {
        applyFilters({ uf: "Todos" }, { immediate: true, reason: "clear-uf" });
      });

      const modal = document.getElementById("filterModal");
      const btnOpen = document.getElementById("btnOpenFilters");
      const btnClose = document.getElementById("btnCloseFilters");
      const btnApply = document.getElementById("btnApplyFilters");
      const btnReset = document.getElementById("btnResetFilters");
      const ufWelcomeModal = document.getElementById("ufWelcomeModal");
      const btnCloseUfWelcome = document.getElementById("btnCloseUfWelcome");
      const btnSkipUfWelcome = document.getElementById("btnSkipUfWelcome");
      const btnBootLoadingRetry = document.getElementById("btnBootLoadingRetry");
      const closeModal = () => {
        if (!modal) return;
        modal.classList.add("hidden");
        modal.setAttribute("aria-hidden", "true");
        syncModalBackdropState();
      };
      const openModal = () => {
        if (!modal) return;
        modal.classList.remove("hidden");
        modal.setAttribute("aria-hidden", "false");
        syncModalBackdropState();
      };
      if (btnOpen) btnOpen.addEventListener("click", openModal);
      if (btnClose) btnClose.addEventListener("click", closeModal);
      if (btnApply) btnApply.addEventListener("click", () => {
        applyFilters({}, { immediate: true, reason: "modal-apply" });
        closeModal();
      });
      if (btnReset) btnReset.addEventListener("click", () => {
        applyFilters({
          dateFrom: state.fullRange.from || state.filters.dateFrom,
          dateTo: state.fullRange.to || state.filters.dateTo,
          uf: "Todos",
          publico: "Todos",
        }, { immediate: true, reason: "modal-reset" });
        closeModal();
      });
      if (modal) {
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeModal();
        });
      }
      if (btnCloseUfWelcome) btnCloseUfWelcome.addEventListener("click", closeUfWelcomeModal);
      if (btnSkipUfWelcome) btnSkipUfWelcome.addEventListener("click", closeUfWelcomeModal);
      if (btnBootLoadingRetry) {
        btnBootLoadingRetry.addEventListener("click", () => {
          tryUnlockUfOnboardingFromRpc("boot-gate-retry").catch((e) => {
            console.error("[UI] [boot] retry unlock failed", { err: String(e) });
          });
        });
      }
      if (ufWelcomeModal) {
        ufWelcomeModal.addEventListener("click", (e) => {
          if (e.target === ufWelcomeModal) closeUfWelcomeModal();
        });
      }
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeModal();
        if (e.key === "Escape") closeUfWelcomeModal();
      });

      const sidebarToggle = document.getElementById("sidebarToggle");
      const syncSidebarAria = () => {
        const expanded = !document.body.classList.contains("sidenav-closed");
        if (sidebarToggle) sidebarToggle.setAttribute("aria-expanded", expanded ? "true" : "false");
      };
      const openSidebar = () => {
        document.body.classList.remove("sidenav-closed");
        syncSidebarAria();
      };
      const closeSidebar = () => {
        document.body.classList.add("sidenav-closed");
        syncSidebarAria();
      };
      const toggleSidebar = () => {
        if (document.body.classList.contains("sidenav-closed")) {
          openSidebar();
        } else {
          closeSidebar();
        }
      };
      if (sidebarToggle) sidebarToggle.addEventListener("click", toggleSidebar);
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "m") toggleSidebar();
        if (e.ctrlKey && e.key.toLowerCase() === "b") toggleSidebar();
        if (e.key === "Escape") closeSidebar();
      });
      syncSidebarAria();

      const btnExportCsv = document.getElementById("btnExportCsv");
      if (btnExportCsv) btnExportCsv.addEventListener("click", ()=>{
        const cols = ["date","uf","city","type","publico","material_type","macrotema","channel","duration_min","user_id"];
        const lines = [cols.join(",")];
        for (const e of state.filtered.slice(0, 200000)) { // protecao
          const row = cols.map(c => {
            const v = (e[c] ?? "");
            const s = String(v).replaceAll('"','""');
            return `"${s}"`;
          });
          lines.push(row.join(","));
        }
        const stamp = new Date().toISOString().slice(0,19).replaceAll(":","-");
        downloadText(`escalada_export_${stamp}.csv`, lines.join("\n"), "text/csv;charset=utf-8");
        showToast("CSV exportado com sucesso.", "success");
      });

      window.addEventListener("hashchange", ()=>{
        state.page = currentHashPage();
        render();
      });
      window.addEventListener("resize", () => {
        maps.forEach((ctx) => {
          if (ctx?.map && isRenderableMapHost(ctx?.host)) {
            ctx.map.invalidateSize({ pan: false, animate: false });
          }
        });
      });
      window.addEventListener("beforeunload", () => {
        try {
          mapRenderRetryTimers.forEach((timer) => clearTimeout(timer));
          mapRenderRetryTimers.clear();
          if (authSubscription && typeof authSubscription.unsubscribe === "function") {
            authSubscription.unsubscribe();
          }
        } catch {}
      });
    }

    async function boot() {
      // skeleton off depois
      const skeleton = document.getElementById("skeleton");
      const app = document.getElementById("app");
      const authModeLabel = document.getElementById("authModeLabel");

      try {
        configureCharts();
        wireUi();
        if (authModeLabel) authModeLabel.textContent = SUPABASE_RPC.authMode;
        if (SUPABASE_RPC.authMode !== "internal") setAuthGate(false);
        bindAuthEvents();
        try {
          initSupabaseClient();
          bindAuthEvents();
        } catch (e) {
          const logFn = DEV_MOCK_FALLBACK ? console.warn : console.error;
          logFn("[UI] [auth] init failed", { err: String(e) });
          if (!DEV_MOCK_FALLBACK) throw e;
          state.lastDataWarning = "Supabase indisponivel. Exibindo dados mock (dev).";
        }

        state.page = currentHashPage();
        syncFilterForm();
        if (skeleton) skeleton.classList.add("hidden");
        if (app) app.classList.remove("hidden");
        lockUfOnboarding("Carregando dados do banco para liberar filtros...");
        // Aguarda o frame para garantir dimensoes dos containers antes do primeiro render/mapa.
        await new Promise((resolve) => requestAnimationFrame(resolve));
        loadCepGeoDictionary().then((count) => {
          if (count > 0 && state.raw) {
            console.debug("[UI] [map] cep-dict ready; rerendering", { rows: count });
            render();
          }
        }).catch(() => {});
        const unlocked = await tryUnlockUfOnboardingFromRpc("boot");
        if (!unlocked) {
          console.warn("[UI] boot: onboarding lock mantido aguardando rpc 200");
        }

        render();
        console.info("[UI] dashboard ready", { page: state.page, filtered: state.filtered.length });
        if (unlocked) showToast("Dashboard pronto para analise.", "success");
        else showToast("Aguardando retorno 200 do banco para liberar filtro de UF.", "warning");
      } catch (e) {
        console.error("[UI] boot failed", { err: String(e) });
        if (skeleton) skeleton.classList.add("hidden");
        if (app) app.classList.remove("hidden");
        if (String(e?.message || e) === "AUTH_REQUIRED") {
          setBootLoadingGate(false);
          updateBootError("Acesso restrito. Faça login para consultar os dados.");
        } else {
          updateBootError("Falha ao inicializar o painel. Alguns graficos podem nao carregar; verifique a conexao com CDN/dados.");
        }
      }
    }

    document.addEventListener("DOMContentLoaded", boot);
  </script>

  <!-- Skeleton -->
  <div id="skeleton" class="p-6 max-w-7xl mx-auto">
    <div class="h-5 w-52 skeleton mb-4"></div>
    <div class="h-9 w-80 skeleton mb-6"></div>
      <div class="grid grid-cols-12 gap-4">
      <div class="col-span-12 lg:col-span-3 card p-5">
        <div class="h-4 w-24 skeleton mb-3"></div>
        <div class="h-9 w-full skeleton mb-3"></div>
        <div class="h-9 w-full skeleton mb-3"></div>
        <div class="h-9 w-full skeleton mb-3"></div>
        <div class="h-32 w-full skeleton"></div>
      </div>
      <div class="col-span-12 lg:col-span-9 grid gap-4">
        <div class="grid grid-cols-12 gap-4">
          <div class="col-span-12 md:col-span-3 card p-5"><div class="h-20 skeleton"></div></div>
          <div class="col-span-12 md:col-span-3 card p-5"><div class="h-20 skeleton"></div></div>
          <div class="col-span-12 md:col-span-3 card p-5"><div class="h-20 skeleton"></div></div>
          <div class="col-span-12 md:col-span-3 card p-5"><div class="h-20 skeleton"></div></div>
        </div>
        <div class="card p-5"><div class="h-72 skeleton"></div></div>
      </div>
    </div>
  </div>

  <!-- App -->
  <div id="app" class="hidden app-shell">
    <button id="sidebarToggle" class="sidebar-toggle" type="button" aria-label="Alternar menu lateral" aria-expanded="false">&#9776;</button>
    <aside id="sidebar" class="sidebar sidenav">
      <div id="sidebarContent" class="sidebar-content">
        <div class="flex items-center gap-3 pb-3 mb-1 border-b border-white/25">
          <div class="w-9 h-9 rounded-xl bg-white/95 flex items-center justify-center shadow-md">
            <img src="./data/bandeira_escalada.svg" alt="Escalada" class="w-5 h-5 object-contain" loading="lazy" />
          </div>
          <div>
            <div class="text-white text-sm font-semibold leading-none">Escalada Sebrae</div>
            <div class="text-white/70 text-[11px] mt-1">Painel institucional</div>
          </div>
        </div>
        <div class="sidebar-section-label">Painel</div>

        <nav id="sidebarNav" class="sidebar-nav flex flex-col gap-1" aria-label="Navegação do painel">
          <a href="#overview" data-nav="overview">
            <span class="flex items-center gap-2">
              <i data-lucide="layout-dashboard" class="w-4 h-4"></i>
              <span>Vis&atilde;o geral</span>
            </span>
          </a>
          <a href="#territory" data-nav="territory">
            <span class="flex items-center gap-2">
              <i data-lucide="map" class="w-4 h-4"></i>
              <span>Territ&oacute;rio</span>
            </span>
          </a>
          <a href="#engagement" data-nav="engagement">
            <span class="flex items-center gap-2">
              <i data-lucide="activity" class="w-4 h-4"></i>
              <span>Engajamento</span>
            </span>
          </a>
          <a href="#content" data-nav="content">
            <span class="flex items-center gap-2">
              <i data-lucide="book-open" class="w-4 h-4"></i>
              <span>Conte&uacute;dos</span>
            </span>
          </a>
        </nav>
      </div>

    </aside>
    <div class="content-wrap">
      <div class="max-w-[1680px] mx-auto px-4 md:px-6 pb-12 pt-6">
        <div id="bootError" class="hidden mb-4 rounded-2xl border border-amber-200 bg-amber-50/90 px-4 py-3 text-sm text-amber-900">
          Falha ao inicializar o painel. Alguns gr&aacute;ficos podem n&atilde;o carregar; verifique a conex&atilde;o com CDN/dados.
        </div>
      <header class="mb-4 section-band rounded-2xl p-3 wrap-hero blur-target">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div class="flex items-center gap-3">
          <div class="w-9 h-9 rounded-xl bg-white flex items-center justify-center border border-slate-200 shadow-sm">
            <img
              src="./data/bandeira_escalada.svg"
              alt="Escalada"
              class="w-5 h-5 object-contain"
              loading="lazy"
            />
          </div>
          <div>
            <h1 class="text-xl md:text-2xl font-display">Escalada &bull; Dashboard Executivo</h1>
            <div class="text-xs text-slate-600 mt-1">Coletando inteligêncial, gerando engajamento e impactanto a sociedade</div>
          </div>
        </div>

        <div class="flex flex-wrap items-center gap-2">
          <button id="btnOpenFilters" class="btn btn-outline btn-sm" title="Filtros">
            <i data-lucide="sliders-horizontal" class="w-4 h-4"></i>
            Filtros
          </button>
          <button id="btnExportCsv" class="btn btn-primary btn-sm" title="Exportar CSV filtrado">
            <i data-lucide="download" class="w-4 h-4"></i>
            Exportar CSV
          </button>
        </div>
      </div>

      <div class="mt-3 flex flex-wrap items-center gap-2">
        <span id="dataCapLabel" class="chip hidden"></span>
        <button id="btnPreset30" class="btn btn-ghost btn-sm" type="button">30 dias</button>
        <button id="btnPreset90" class="btn btn-ghost btn-sm" type="button">90 dias</button>
        <button id="btnPresetAll" class="btn btn-ghost btn-sm" type="button">Per&iacute;odo completo</button>
        <button id="btnClearUf" class="btn btn-ghost btn-sm" type="button">Limpar UF</button>
      </div>

      <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-2">
        <div class="card p-3 kpi kpi-compact">
          <div class="label">Atendimentos</div>
          <div id="kpiAtend" class="value">&mdash;</div>
          <div class="flex items-center justify-between text-[11px] text-slate-600">
            <span id="kpiAtendDelta" class="delta">&mdash;</span>
            <span>Meta <strong id="kpiAtendTarget">&mdash;</strong></span>
          </div>
          <div class="progress mt-2"><span id="kpiAtendBar"></span></div>
        </div>
        <div class="card p-3 kpi kpi-compact">
          <div class="label">Inscritos</div>
          <div id="kpiAtivos" class="value">&mdash;</div>
          <div class="flex items-center justify-between text-[11px] text-slate-600">
            <span id="kpiAtivosDelta" class="delta">&mdash;</span>
            <span>Meta <strong id="kpiAtivosTarget">&mdash;</strong></span>
          </div>
          <div class="progress mt-2"><span id="kpiAtivosBar"></span></div>
        </div>
        <div class="card p-3 kpi kpi-compact">
          <div class="label">Convers&atilde;o (inscrito&rarr;atendido)</div>
          <div id="kpiConv" class="value">&mdash;</div>
          <div class="flex items-center justify-between text-[11px] text-slate-600">
            <span id="kpiConvDelta" class="delta">&mdash;</span>
            <span>Meta <strong id="kpiConvTarget">&mdash;</strong></span>
          </div>
          <div class="progress mt-2"><span id="kpiConvBar"></span></div>
        </div>
      </div>
      </header>

    <main class="grid gap-4 main wrap-atmosphere p-3 blur-target">
        <!-- PAGES -->
        <section data-page="overview" class="grid grid-cols-12 gap-4 wrap-accent-blue wrap-soft p-4">
          <div class="col-span-12 card p-5 reveal">
            <div>
              <h2 class="section-title">Atendimentos por UF</h2>
              <div class="text-sm text-slate-600">Priorize recursos onde a demanda &bull; maior.</div>
            </div>
            <div id="ufPills" class="mt-4 uf-pills"></div>
          </div>

          <div class="col-span-12 lg:col-span-6 card p-5 reveal">
            <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
              <div>
                <h2 class="section-title">Inscri&ccedil;&otilde;es ao longo do tempo</h2>
                <div class="text-sm text-slate-600">Identifica picos, sazonalidade e impacto de campanhas.</div>
                <div class="flex flex-wrap gap-2 mt-2 text-xs text-slate-600">
                  <span class="badge">Pico <strong id="inscrPeak">&mdash;</strong></span>
                  <span class="badge">M&eacute;dia <strong id="inscrAvg">&mdash;</strong></span>
                </div>
              </div>
              <button data-nav="overview" class="chip soft">
                <i data-lucide="trending-up" class="w-4 h-4"></i>Linha do tempo
              </button>
            </div>
            <div class="mt-4 h-52">
              <canvas id="chartInscrLine"></canvas>
            </div>
          </div>

          <div class="col-span-12 lg:col-span-6 card p-5 reveal">
            <div class="flex items-center justify-between">
              <div>
                <h2 class="section-title">Mapa de densidade</h2>
                <div class="text-sm text-slate-600">Distribui&ccedil;&atilde;o territorial dos registros.</div>
              </div>
              <button data-nav="territory" class="chip soft">
                <i data-lucide="map" class="w-4 h-4"></i>Territ&oacute;rio
              </button>
            </div>
            <div id="map" style="height:280px;min-height:280px;" class="mt-4 h-[280px] rounded-2xl overflow-hidden"></div>
          </div>

          <div class="col-span-12 lg:col-span-6 card p-5 reveal delay-2">
              <div class="flex items-center justify-between">
                <h2 class="section-title">Interesses por Macrotema</h2>
                <button data-nav="content" class="chip soft">Conte&uacute;dos</button>
              </div>
              <div class="text-sm text-slate-600">Pauta estrat&eacute;gica e trilhas priorit&aacute;rias.</div>
              <div class="mt-4 h-56">
                <canvas id="chartMacro"></canvas>
              </div>
          </div>
          <div class="col-span-12 lg:col-span-6 card p-5 reveal delay-3">
              <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                <h2 class="section-title">Interesses por Compet&ecirc;ncias</h2>
                <div class="flex items-center gap-2 flex-wrap sm:justify-end">
                  <button id="btnCompModeBncc" type="button" class="btn btn-sm btn-ghost is-active">BNCC</button>
                  <button id="btnCompModeEntrecomp" type="button" class="btn btn-sm btn-ghost">EntreComp</button>
                </div>
              </div>
              <div class="text-sm text-slate-600">Distribui&ccedil;&atilde;o das compet&ecirc;ncias priorit&aacute;rias do recorte.</div>
              <div class="mt-4 h-56">
                <canvas id="chartMaterial"></canvas>
              </div>
          </div>

          <div class="col-span-12 card p-5">
            <div class="grid grid-cols-12 gap-4">
              <div class="col-span-12 lg:col-span-4">
                <h2 class="section-title">Sinais executivos</h2>
                <div class="text-sm text-slate-600 mt-1">Leitura r&aacute;pida para prioriza&ccedil;&atilde;o de agenda.</div>
                <div class="grid gap-2 mt-3">
                  <div class="metric">
                    <span class="label">UF l&iacute;der</span>
                    <span id="atendTopUf" class="value">&mdash;</span>
                  </div>
                  <div class="metric">
                    <span class="label">Concentra&ccedil;&atilde;o (5 UFs)</span>
                    <span id="atendTopShare" class="value">&mdash;</span>
                  </div>
                </div>
              </div>
              <div class="col-span-12 lg:col-span-4">
                <h2 class="section-title">Resumo do per&iacute;odo</h2>
                <div class="text-sm text-slate-600 mt-1">Narrativa consolidada dos principais indicadores.</div>
                <ul id="summaryList" class="insight-list mt-3"></ul>
              </div>
              <div class="col-span-12 lg:col-span-4">
                <h2 class="section-title">Alertas e oportunidades</h2>
                <div class="text-sm text-slate-600 mt-1">Pontos que merecem a&ccedil;&atilde;o t&aacute;tica ou institucional.</div>
                <ul id="insightsList" class="insight-list mt-3"></ul>
              </div>
            </div>
          </div>
        </section>

        <section data-page="territory" class="hidden grid grid-cols-12 gap-4 wrap-accent-green wrap-soft p-4">
          <div class="col-span-12 card p-5">
            <h2 id="terrHighlightTitle" class="section-title">Cidades em destaque</h2>
            <div id="terrHighlightSubtitle" class="text-sm text-slate-600">Concentra&ccedil;&atilde;o urbana e oportunidades regionais.</div>
            <div id="topCitiesList" class="mt-4 uf-pills top-cities-pills"></div>
          </div>

          <div class="col-span-12 lg:col-span-6 card p-5">
            <h2 class="section-title">Cobertura territorial</h2>
            <div class="text-sm text-slate-600">Amplitude geogr&aacute;fica do per&iacute;odo.</div>
            <div class="grid grid-cols-2 gap-3 mt-4">
              <div class="metric">
                <span class="label">UFs ativas</span>
                <span id="terrUfs" class="value">&mdash;</span>
              </div>
              <div class="metric">
                <span class="label">Cidades</span>
                <span id="terrCities" class="value">&mdash;</span>
              </div>
              <div class="metric">
                <span class="label">Usu&aacute;rios &uacute;nicos</span>
                <span id="terrUsers" class="value">&mdash;</span>
              </div>
              <div class="metric">
                <span class="label">Atend./dia</span>
                <span id="terrAtendDay" class="value">&mdash;</span>
              </div>
              <div class="metric">
                <span id="terrCoverageLabel" class="label">Cobertura por UF (inscritos)</span>
                <span id="terrUfCoverage" class="value">&mdash;</span>
              </div>
            </div>
          </div>

          <div class="col-span-12 lg:col-span-6 card p-5">
            <h2 class="section-title">Mapa de densidade</h2>
            <div class="text-sm text-slate-600">Distribui&ccedil;&atilde;o territorial dos registros.</div>
            <div id="mapTerritory" style="height:220px;min-height:220px;" class="mt-4 h-[220px] rounded-2xl overflow-hidden"></div>
          </div>

          <div class="col-span-12 card p-5">
            <h2 id="terrRankTitle" class="section-title">Atendimentos por UF (10 maiores)</h2>
            <div class="mt-4 h-64"><canvas id="chartUfAtend2"></canvas></div>
          </div>
        </section>

        <section data-page="engagement" class="hidden grid grid-cols-12 gap-4 wrap-accent-magenta wrap-soft p-4">
          <div class="col-span-12 lg:col-span-7 card p-5">
            <h2 class="section-title">Atendimentos ao longo do tempo</h2>
            <div class="text-sm text-slate-600">Picos podem indicar eventos regionais ou gargalos.</div>
            <div class="flex flex-wrap gap-2 mt-2 text-xs text-slate-600">
              <span class="badge">M&eacute;dia <strong id="atendAvg">&mdash;</strong></span>
            </div>
            <div class="mt-4 h-64"><canvas id="chartAtendLine"></canvas></div>
          </div>
          <div class="col-span-12 lg:col-span-5 card p-5">
            <h2 class="section-title">Funil de engajamento</h2>
            <div class="text-sm text-slate-600">Convers&otilde;es entre etapas da jornada.</div>
            <div class="grid gap-3 mt-4 text-sm">
              <div class="flex items-center justify-between">
                <span>Inscritos</span>
                <strong id="funnelInscr">&mdash;</strong>
              </div>
              <div>
                <div class="flex items-center justify-between">
                  <span>Atendimentos</span>
                  <span><strong id="funnelAtend">&mdash;</strong>&mdash;<span id="funnelAtendPct">&mdash;</span></span>
                </div>
                <div class="progress mt-1"><span id="funnelAtendBar"></span></div>
              </div>
            </div>
          </div>

          <div class="col-span-12 md:col-span-6 card p-5">
            <h2 class="section-title">Distribui&ccedil;&atilde;o por p&uacute;blico</h2>
            <div class="text-sm text-slate-600">Segmenta&ccedil;&atilde;o para estrat&eacute;gia.</div>
            <div class="mt-4 h-64"><canvas id="chartPublico"></canvas></div>
          </div>
          <div class="col-span-12 md:col-span-6 card p-5">
            <h2 class="section-title">Canais de entrada</h2>
            <div class="text-sm text-slate-600">Origem dos atendimentos e capilaridade.</div>
            <div class="mt-4 h-64"><canvas id="chartChannels"></canvas></div>
          </div>

        </section>

        <section data-page="content" class="hidden grid grid-cols-12 gap-4 wrap-soft p-4">
          <div class="col-span-12 card p-5">
            <h2 class="section-title">Macrotemas</h2>
            <div class="text-sm text-slate-600">Base para planejamento de portf&oacute;lio.</div>
            <div class="mt-4 h-72"><canvas id="chartMacroBar"></canvas></div>
          </div>

          <div class="col-span-12 card p-5">
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
              <h2 class="section-title">Interesses por Compet&ecirc;ncias</h2>
              <div class="flex items-center gap-2 flex-wrap sm:justify-end">
                <button id="btnCompModeBnccContent" type="button" class="btn btn-sm btn-ghost is-active">BNCC</button>
                <button id="btnCompModeEntrecompContent" type="button" class="btn btn-sm btn-ghost">EntreComp</button>
              </div>
            </div>
            <div class="text-sm text-slate-600">Distribui&ccedil;&atilde;o das compet&ecirc;ncias priorit&aacute;rias do recorte.</div>
            <div class="mt-4 h-72"><canvas id="chartMatBar"></canvas></div>
          </div>

        </section>

        <footer class="text-xs text-slate-500 mt-2">
          &copy; Escalada &bull; Relat&oacute;rio executivo &bull; Vers&atilde;o est&aacute;tica para an&aacute;lise institucional.
        </footer>
      </main>
      </div>
    </div>
  </div>

  <div id="bootLoadingGate" class="boot-loading-gate hidden" aria-live="polite" aria-modal="true" role="dialog">
    <div class="boot-loading-card">
      <div class="flex items-center gap-3">
        <div class="loading-spinner" aria-hidden="true"></div>
        <div>
          <h2 class="section-title">Um segundinho</h2>
          <p id="bootLoadingMessage" class="text-sm text-slate-700 mt-1">
            Aguardando retorno do banco de dados...
          </p>
        </div>
      </div>
      <div class="mt-4 flex justify-end">
        <button id="btnBootLoadingRetry" class="btn btn-outline btn-sm" type="button">Tentar novamente</button>
      </div>
    </div>
  </div>

  <div id="authGate" class="auth-gate hidden" aria-live="polite" aria-modal="true" role="dialog">
    <div class="auth-card">
      <h2 class="section-title">Acesso restrito</h2>
      <p id="authGateMessage" class="text-sm text-slate-700 mt-2">
        Faça login para acessar os dados executivos do dashboard.
      </p>
      <div class="mt-4 flex items-center gap-2">
        <button id="btnAuthLogin" class="btn btn-primary btn-sm" type="button">
          <i data-lucide="log-in" class="w-4 h-4"></i>
          Fazer login
        </button>
      </div>
      <p class="text-xs text-slate-500 mt-3">
        Modo de autenticação: <strong id="authModeLabel">interno</strong> (usuário autenticado no Supabase).
      </p>
    </div>
  </div>

  <div id="filterModal" class="modal-backdrop hidden" aria-hidden="true">
    <div class="modal-card">
      <div class="flex items-center justify-between">
        <h2 class="section-title">Filtros</h2>
        <button id="btnCloseFilters" class="btn btn-ghost btn-sm" title="Fechar">
          <i data-lucide="x" class="w-4 h-4"></i>
        </button>
      </div>
      <div class="grid gap-4 mt-3">
        <div class="grid grid-cols-2 gap-2">
          <div>
            <label class="label">De</label>
            <input id="fFrom" type="date" class="input w-full mt-1" />
          </div>
          <div>
            <label class="label">At&eacute;</label>
            <input id="fTo" type="date" class="input w-full mt-1" />
          </div>
        </div>
        <div>
          <label class="label">UF</label>
          <select id="fUf" class="input w-full mt-1"></select>
        </div>
        <div>
          <label class="label">P&uacute;blico</label>
          <select id="fPublico" class="input w-full mt-1"></select>
        </div>
      </div>
      <div class="mt-4 flex justify-end gap-2">
        <button id="btnResetFilters" class="btn btn-outline btn-sm" type="button">Resetar</button>
        <button id="btnApplyFilters" class="btn btn-primary btn-sm" type="button">Aplicar</button>
      </div>
    </div>
  </div>

  <div id="ufWelcomeModal" class="modal-backdrop hidden" aria-hidden="true" aria-modal="true" role="dialog">
    <div class="modal-card">
      <div class="flex items-center justify-between">
        <h2 class="section-title">Qual &eacute; a sua UF?</h2>
        <button id="btnCloseUfWelcome" class="btn btn-ghost btn-sm" title="Fechar">
          <i data-lucide="x" class="w-4 h-4"></i>
        </button>
      </div>
      <p class="text-sm text-slate-600 mt-2">
        Selecione sua UF para iniciar o dashboard com filtro imediato e per&iacute;odo padr&atilde;o da &uacute;ltima semana.
      </p>
      <div id="ufWelcomeList" class="uf-onboarding-list mt-3"></div>
      <div class="mt-4 flex justify-end">
        <button id="btnSkipUfWelcome" class="btn btn-outline btn-sm" type="button">Continuar sem filtrar</button>
      </div>
    </div>
  </div>
  <div id="toast" class="hidden fixed right-5 bottom-5 z-[95] rounded-xl border border-slate-300 bg-white/95 px-4 py-2 text-sm font-semibold text-slate-800 shadow-lg"></div>
  <!-- padrao solicitado: clearInterval(poller) quando detectar window.circleUser.email (mesmo se aqui nao usar) -->
  <script>
    (function () {
      let poller = setInterval(() => {
        try {
          const email = window.circleUser && window.circleUser.email;
          if (email) {
            console.info("[UI] [circle] detected user email", { email: String(email) });
            clearInterval(poller);
            console.debug("[UI] [circle] clearInterval(poller) executed");
          }
        } catch (e) {
          console.warn("[UI] [circle] poll error (ignored)", { err: String(e) });
        }
      }, 800);
    })();
  </script>
</body>
</html>


